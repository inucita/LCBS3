/*
 * This file is generated by Entity Class Compiler, (c) CroTeam 1997-98
 */


#include "StdH.h"
#include <Engine/Entities/InternalClasses.h>
#include <Engine/Math/Geometry.inl>
#include <Engine/Math/Float.h>
#include <Engine/Base/Stream.h>
#include <Engine/World/World.h>
#include <Engine/Network/CNetwork.h>
#include <Engine/Network/Server.h>
#include <Engine/Network/EntityHashing.h>
#include <Engine/Entities/EntityCollision.h>
#include <Engine/Entities/EntityClass.h>
#include <Engine/Templates/StaticArray.cpp>
#include <Engine/Templates/BSP.h>
#include <Engine/Base/ListIterator.inl>
#include <Engine/World/WorldSettings.h>
#include <Engine/World/WorldCollision.h>
#include <Engine/Math/Clipping.inl>
#include <Engine/Light/LightSource.h>
#include <Engine/Entities/LastPositions.h>
#include <Engine/Templates/StaticStackArray.cpp>
#include <Engine/Templates/DynamicArray.cpp>
#include <Engine/Base/Console.h>
#include <Engine/Base/CRC.h>
#include <Engine/Network/SessionState.h>
#include <Engine/Terrain/Terrain.h>
#define CLEARMEM(var) memset(&var, 0, sizeof(var))


#include <Classes/MovableEntity.h>
#include <Classes/MovableEntity_tables.h>


#define ANYEXCEPTION  ...
template CStaticStackArray<CBrushPolygon*>;

#define MAXCOLLISIONRETRIES 4*4
extern FLOAT phy_fCollisionCacheAhead;
extern FLOAT phy_fCollisionCacheAround;

//0211
#define AN_LOOPING              (1UL<<0) // looping animation
#define AN_NORESTART            (1UL<<1) // dont restart anim
#define AN_PAUSED				(1UL<<2)
#define AN_CLEAR                (1UL<<3) // do new clear state before adding animation

// force breakpoint (debug)
extern INDEX dbg_bBreak;
// must be in separate function to disable stupid optimizer
extern void Breakpoint(void);
 

// add acceleration to velocity
static inline void AddAcceleration(
	FLOAT3D &vCurrentVelocity, const FLOAT3D &vDesiredVelocity, 
	FLOAT fAcceleration, FLOAT fDecceleration)
{
	// if desired velocity is smaller than current velocity
	if (vDesiredVelocity.Length()<vCurrentVelocity.Length()) {
		fAcceleration=fDecceleration;
	}
	// find difference between current and desired velocities
	FLOAT3D vDelta = vDesiredVelocity-vCurrentVelocity;
	// accelerate in the direction of the difference with given maximum acceleration
	FLOAT fDelta = vDelta.Length();
	if (fDelta>fAcceleration) {
		vCurrentVelocity += vDelta*(fAcceleration/fDelta);
	}
 else {
		vCurrentVelocity = vDesiredVelocity;
	}
}

// add gravity acceleration to velocity along an axis
static inline void AddGAcceleration(
	FLOAT3D &vCurrentVelocity, const FLOAT3D &vGDir, 
	FLOAT fGA, FLOAT fGV)
{
	// disassemble speed
	FLOAT3D vCurrentParallel, vCurrentOrthogonal;
	GetParallelAndNormalComponents(vCurrentVelocity, vGDir, vCurrentOrthogonal, vCurrentParallel);

	// if not already going down at max speed
	if (! (vCurrentOrthogonal%vGDir>=fGV)) {
		// add accelleration to parallel speed
		vCurrentOrthogonal+=vGDir*fGA;

		// if going down at max speed
		if (vCurrentOrthogonal%vGDir>=fGV) {
			// clamp
			vCurrentOrthogonal = vGDir*fGV;
		}
	}

	// assemble speed back
	vCurrentVelocity = vCurrentParallel+vCurrentOrthogonal;
}

// NOTE:
// this is pulled out into a separate function because, otherwise, VC6 generates
// invalid code when optimizing this. no clue why is that so.

#pragma inline_depth(0)
static void CheckAndAddGAcceleration(CMovableEntity *pen, FLOAT3D &vTranslationAbsolute, FLOAT fTickQuantum)
{
	// if there is forcefield involved
	if (pen->en_fForceA>0.01f) {
		// add force acceleration
		FLOAT fGV=pen->en_fForceV*fTickQuantum;
		FLOAT fGA=pen->en_fForceA*fTickQuantum*fTickQuantum;
		AddGAcceleration(vTranslationAbsolute, pen->en_vForceDir, fGA, fGV);
	}
}
#pragma inline_depth()  // see important note above


// add acceleration to velocity, but only along a plane
static inline void AddAccelerationOnPlane(
	FLOAT3D &vCurrentVelocity, const FLOAT3D &vDesiredVelocity, 
	FLOAT fAcceleration, FLOAT fDecceleration,
	const FLOAT3D &vPlaneNormal)
{
	FLOAT3D vCurrentParallel, vCurrentOrthogonal;
	GetParallelAndNormalComponents(vCurrentVelocity, vPlaneNormal, vCurrentOrthogonal, vCurrentParallel);
	FLOAT3D vDesiredParallel;
	GetNormalComponent(vDesiredVelocity, vPlaneNormal, vDesiredParallel);
	AddAcceleration(vCurrentParallel, vDesiredParallel, fAcceleration, fDecceleration);
	vCurrentVelocity = vCurrentParallel+vCurrentOrthogonal;
}

// add acceleration to velocity, for roller-coaster slope -- slow!
static inline void AddAccelerationOnPlane2(
	FLOAT3D &vCurrentVelocity, const FLOAT3D &vDesiredVelocity, 
	FLOAT fAcceleration, FLOAT fDecceleration,
	const FLOAT3D &vPlaneNormal, const FLOAT3D &vGravity)
{
	// get down and horizontal direction
	FLOAT3D vDn;
	GetNormalComponent(vGravity, vPlaneNormal, vDn);
	vDn.Normalize();
	FLOAT3D vRt = vPlaneNormal*vDn;
	vRt.Normalize();

	// add only horizontal acceleration
	FLOAT3D vCurrentParallel, vCurrentOrthogonal;
	GetParallelAndNormalComponents(vCurrentVelocity, vRt, vCurrentParallel, vCurrentOrthogonal);
	FLOAT3D vDesiredParallel;
	GetParallelComponent(vDesiredVelocity, vRt, vDesiredParallel);
	AddAcceleration(vCurrentParallel, vDesiredParallel, fAcceleration, fDecceleration);
	vCurrentVelocity = vCurrentParallel+vCurrentOrthogonal;
}

// max number of retries during movement
static INDEX _ctTryToMoveCheckCounter;
static INDEX _ctSliding;
static FLOAT3D _vSlideOffDir;
   // move away direction for sliding
static FLOAT3D _vSlideDir;
static void InitTryToMove(void)
{
	_ctTryToMoveCheckCounter = MAXCOLLISIONRETRIES;
	_ctSliding = 0;
	_vSlideOffDir = FLOAT3D(0,0,0);
	_vSlideDir = FLOAT3D(0,0,0);
}

// array of forces for current entity
class CEntityForce {
public:
	CEntityPointer ef_penEntity;
	INDEX ef_iForceType;
	FLOAT ef_fRatio;
    // how much of entity this force gets [0-1]
	inline void Clear(void) {
		ef_penEntity = NULL;
	}
;
	~CEntityForce(void) {
		Clear();
	}
;
}
;
                                                            
static CStaticStackArray<CEntityForce> _aefForces;

void ClearMovableEntityCaches(void)
{
	_aefForces.Clear();
}


void CMovableEntity::SetDefaultProperties(void) {
	en_vDesiredTranslationRelative = FLOAT3D(0.0f , 0.0f , 0.0f);
	en_aDesiredRotationRelative = ANGLE3D(0 , 0 , 0);
	en_vCurrentTranslationAbsolute = FLOAT3D(0.0f , 0.0f , 0.0f);
	en_aCurrentRotationAbsolute = ANGLE3D(0 , 0 , 0);
	en_penReference = NULL;
	en_vReferencePlane = FLOAT3D(0.0f , 0.0f , 0.0f);
	en_iReferenceSurface = 0;
	en_penLastValidReference = NULL;
	en_penLastValidReferenceTmp = NULL;
	en_tmLastSignificantVerticalMovement = 0.0f;
	en_tmLastBreathed = 0;
	en_tmMaxHoldBreath = 5.0f;
	en_fDensity = 5000.0f;
	en_tmLastSwimDamage = 0;
	en_iUpContent = 0;
	en_iDnContent = 0;
	en_fImmersionFactor = 1.0f;
	en_vGravityDir = FLOAT3D(0 , - 1 , 0);
	en_fGravityA = 0.0f;
	en_fGravityV = 0.0f;
	en_vForceDir = FLOAT3D(1 , 0 , 0);
	en_fForceA = 0.0f;
	en_fForceV = 0.0f;
	en_tmJumped = -1.0f;
	en_tmMaxJumpControl = 0.5f;
	en_fJumpControlMultiplier = 0.5f;
	en_fAcceleration = 200.0f;
	en_fDeceleration = 40.0f;
	en_fStepUpHeight = 1.0f;
	en_fStepDnHeight = -1.0f;
	en_fBounceDampParallel = 0.5f;
	en_fBounceDampNormal = 0.5f;
	en_fCollisionSpeedLimit = 20.0f;
	en_fCollisionDamageFactor = 20.0f;
	en_boxMovingEstimate = FLOATaabbox3D(FLOAT3D (0 , 0 , 0) , 0.01f);
	en_boxNearCached = FLOATaabbox3D(FLOAT3D (0 , 0 , 0) , 0.01f);
	en_vIntendedTranslation = FLOAT3D(0 , 0 , 0);
	en_mIntendedRotation = FLOATmatrix3D(0);
	en_tmEntityTime = 0.0f;
	m_bReferenceMovingInY = FALSE ;
	m_bReferenceRotatingNonY = FALSE ;
	m_iPlayerRefCounter = 0;
	en_vDesiredTranslationFinal = FLOAT3D(0.0f , 0.0f , 0.0f);
	m_tmMoveStart = 0;
	m_tickMoveStart = 0.0f;
	m_bForceStop = FALSE ;
	m_bBlockDown = FALSE ;
	m_bBlockUp = FALSE ;
	m_bStair = FALSE ;
	m_bFallDownToFloor = FALSE ;
	CRationalEntity::SetDefaultProperties();
}

TIME CMovableEntity::GetLerpedEntityTime() {
return en_tmEntityTime  + _pTimer  -> GetLerpFactor  () * _pTimer  -> TickQuantum ;
}
BOOL CMovableEntity::IsActionApplied() {
return TRUE ;
}
void CMovableEntity::SetActionApplied() {
}
void CMovableEntity::ClearActionApplied() {
}
BOOL CMovableEntity::IsReapplyingActions() {
return FALSE ;
}
void CMovableEntity::SetReapplyingActions() {
}
void CMovableEntity::ClearReapplyingActions() {
}
void CMovableEntity::StopPlayer() {
}

void CMovableEntity::ApplyDeadReckoning() 
{
if((IsPlayer  () && (_pNetwork  -> IsPlayerLocal  (this ) || _pNetwork  -> IsPlayingDemo  ())) || _pNetwork  -> IsGameFinished  ()){
return ;
}
;
FLOAT3D deltaPos  = (en_vDesiredTranslationFinal  - en_plPlacement  . pl_PositionVector );
if(deltaPos  . Length  () < 0.5){
en_vDesiredTranslationFinal  = en_plPlacement  . pl_PositionVector ;
en_vCurrentTranslationAbsolute  = FLOAT3D (0.0f , 0.0f , 0.0f);
en_aCurrentRotationAbsolute  = FLOAT3D (0.0f , 0.0f , 0.0f);
if(IsAnimationPlaying  (53)){
return ;
}
NewClearState  (0.4f);
return ;
}
extern  TIME  _tmLocalTick ;
TIME  tmLerpTime ;
if(_pNetwork  -> IsPlayingDemo  ()){
tmLerpTime  = _pNetwork  -> ga_tmNextDemoTick  - _pTimer  -> TickQuantum ;
}
else {
tmLerpTime  = _pTimer  -> CurrentTick  ();
}
CPlacement3D plSpeed ;
FLOAT fLerpFactor  = (tmLerpTime  - en_tmLastPlacementTime ) / _pTimer  -> TickQuantum ;
plSpeed  . pl_PositionVector  = en_vCurrentTranslationAbsolute  * _pTimer  -> TickQuantum ;
plSpeed  . pl_OrientationAngle  = en_aCurrentRotationAbsolute  * _pTimer  -> TickQuantum ;
CPlacement3D plLerped ;
plLerped  . Extrapolate  (en_plLastPlacementReceived  , plSpeed  , fLerpFactor );
for(int  i  = 1;
i  <= 3;
i  ++){
plLerped  . pl_OrientationAngle  (i ) = WrapAngle  (plLerped  . pl_OrientationAngle  (i ));
en_plPlacement  . pl_OrientationAngle  (i ) = WrapAngle  (en_plPlacement  . pl_OrientationAngle  (i ));
}
FLOAT3D delta  = (plLerped  . pl_OrientationAngle  - en_plPlacement  . pl_OrientationAngle ) + (plLerped  . pl_PositionVector  - en_plPlacement  . pl_PositionVector );
if(delta  . Length  () > 0.01){
if(en_plpLastPositions  != NULL ){
en_plpLastPositions  -> AddPosition  (en_plPlacement  . pl_PositionVector );
}
SetPlacement  (plLerped );
}
CPlacement3D plLerped2 ;
plLerped2  . Extrapolate  (en_plLastPlacementReceived  , plSpeed  , fLerpFactor  - 1);
en_plLastPlacement  = plLerped2 ;
en_vNextPosition  = en_plPlacement  . pl_PositionVector ;
FLOATmatrix3D mRotation ;
MakeRotationMatrix  (mRotation  , en_plPlacement  . pl_OrientationAngle );
en_mNextRotation  = mRotation ;
ClientCacheNearPolygons  ();
}

void CMovableEntity::AdjustDeadReckoning(CPlacement3D plPlacement,CPlacement3D plSpeed,TIME tmNewTime) 
{
en_vCurrentTranslationAbsolute  = plSpeed  . pl_PositionVector ;
en_aCurrentRotationAbsolute  = plSpeed  . pl_OrientationAngle ;
en_plLastPlacementReceived  = plPlacement ;
en_tmLastPlacementTime  = tmNewTime ;
ApplyDeadReckoning  ();
}

void CMovableEntity::AdjustDeadReckoningNew(CPlacement3D plPlacement,CPlacement3D plSpeed,TIME tmNewTime,FLOAT3D plPlacementFinal) 
{
en_vCurrentTranslationAbsolute  = plSpeed  . pl_PositionVector ;
en_aCurrentRotationAbsolute  = plSpeed  . pl_OrientationAngle ;
en_plLastPlacementReceived  = plPlacement ;
en_tmLastPlacementTime  = tmNewTime ;
en_vDesiredTranslationFinal  = plPlacementFinal ;
ApplyDeadReckoning  ();
}
 CMovableEntity::CMovableEntity(void) 
{
en_pbpoStandOn  = NULL ;
en_apbpoNearPolygons  . SetAllocationStep  (5);
}
 CMovableEntity:: ~ CMovableEntity(void) 
{
}
void CMovableEntity::OnInitialize(const CEntityEvent & eeInput) 
{
CRationalEntity  :: OnInitialize  (eeInput );
ClearTemporaryData  ();
en_vIntendedTranslation  = FLOAT3D (0 , 0 , 0);
en_mIntendedRotation  . Diagonal  (1.0f);
en_boxNearCached  = FLOATaabbox3D ();
en_boxMovingEstimate  = FLOATaabbox3D ();
en_pbpoStandOn  = NULL ;
en_pwoWorld  -> wo_ehEntityHashContainer  . AddEntity  (this );
}
void CMovableEntity::OnEnd(void) 
{
if(en_lnInMovers  . IsLinked  ()){
en_lnInMovers  . Remove  ();
}
ClearTemporaryData  ();
en_boxNearCached  = FLOATaabbox3D ();
en_boxMovingEstimate  = FLOATaabbox3D ();
CRationalEntity  :: OnEnd  ();
}
void CMovableEntity::Copy(CEntity & enOther,ULONG ulFlags) 
{
CRationalEntity  :: Copy  (enOther  , ulFlags );
CMovableEntity  * pmenOther  = (CMovableEntity  *) (& enOther );
ClearTemporaryData  ();
en_boxNearCached  = FLOATaabbox3D ();
en_boxMovingEstimate  = FLOATaabbox3D ();
en_pbpoStandOn  = NULL ;
en_plLastPlacement  = pmenOther  -> en_plLastPlacement ;
if(pmenOther  -> en_lnInMovers  . IsLinked  ()){
AddToMovers  ();
}
}

void CMovableEntity::ClearTemporaryData(void) 
{
en_plLastPlacement  = en_plPlacement ;
en_vNextPosition  = en_plPlacement  . pl_PositionVector ;
en_mNextRotation  = en_mRotation ;
en_vAppliedTranslation  = FLOAT3D (0 , 0 , 0);
en_mAppliedRotation  . Diagonal  (1.0f);
}
void CMovableEntity::Read_t(CTStream * istr,BOOL bNetwork) 
{
CRationalEntity  :: Read_t  (istr  , bNetwork );
ClearTemporaryData  ();
if(istr  -> PeekID_t  () == CChunkID  ("MENT")){
istr  -> ExpectID_t  ("MENT");
INDEX ibpo ;
(* istr ) >> ibpo ;
en_pbpoStandOn  = GetWorldPolygonPointer  (ibpo );
BOOL bAnyNULLs  = FALSE ;
INDEX ctbpoNear ;
(* istr ) >> ctbpoNear ;
if(ctbpoNear  > 0){
en_apbpoNearPolygons  . PopAll  ();
en_apbpoNearPolygons  . Push  (ctbpoNear );
for(INDEX i  = 0;
i  < ctbpoNear ;
i  ++){
INDEX ibpo ;
(* istr ) >> ibpo ;
en_apbpoNearPolygons  [ i  ] = GetWorldPolygonPointer  (ibpo );
if(en_apbpoNearPolygons  [ i  ] == NULL ){
bAnyNULLs  = TRUE ;
}
}
if(bAnyNULLs ){
CPrintF  ("NULL saved for near polygon!\n");
en_apbpoNearPolygons  . PopAll  ();
}
}
}
BOOL bWasMoving ;
(* istr ) >> bWasMoving ;
if(bWasMoving ){
AddToMovers  ();
}
en_pwoWorld  -> wo_ehEntityHashContainer  . AddEntity  (this );
}
void CMovableEntity::Write_t(CTStream * ostr,BOOL bNetwork) 
{
CRationalEntity  :: Write_t  (ostr  , bNetwork );
ostr  -> WriteID_t  ("MENT");
INDEX ibpo ;
ibpo  = GetWorldPolygonIndex  (en_pbpoStandOn );
(* ostr ) << ibpo ;
INDEX ctbpoNear  = en_apbpoNearPolygons  . Count  ();
(* ostr ) << ctbpoNear ;
for(INDEX i  = 0;
i  < ctbpoNear ;
i  ++){
INDEX ibpo ;
ibpo  = GetWorldPolygonIndex  (en_apbpoNearPolygons  [ i  ]);
(* ostr ) << ibpo ;
}
(* ostr ) << en_lnInMovers  . IsLinked  ();
}
CPlacement3D CMovableEntity::GetLerpedPlacement(void)const 
{
FLOAT fLerpFactor ;
CPlacement3D plLerped ;
CPlacement3D plSpeed ;
fLerpFactor  = _pTimer  -> GetLerpFactor2  ();
plLerped  . Lerp  (en_plLastPlacement  , en_plPlacement  , fLerpFactor );
return plLerped ;
}
void CMovableEntity::AddToMovers(void) 
{
if(! en_lnInMovers  . IsLinked  ()){
en_pwoWorld  -> wo_lhMovers  . AddTail  (en_lnInMovers );
if(IsSentOverNet  () && ! IsPlayer  ()){
extern  CEntityMessage  _emEntityMessage ;
_emEntityMessage  . WritePlacementNotify  (en_ulID  , TRUE );
_pNetwork  -> ga_srvServer  . SendMessage  (_emEntityMessage );
}
}
}
void CMovableEntity::AddToMoversDuringMoving(void) 
{
if(en_lnInMovers  . IsLinked  ()){
return ;
}
AddToMovers  ();
en_ulPhysicsFlags  |= EPF_FORCEADDED ;
}
void CMovableEntity::SetDesiredRotation(const ANGLE3D & aRotation) 
{
FLOAT fRotationDelta ;
fRotationDelta  = fabs  (en_aDesiredRotationRelative  (1) - aRotation  (1)) 
+ fabs  (en_aDesiredRotationRelative  (2) - aRotation  (2)) 
+ fabs  (en_aDesiredRotationRelative  (3) - aRotation  (3));
extern  FLOAT ser_fOrientationTreshold ;
if(_pNetwork  -> IsServer  () && IsSentOverNet  () && ! IsPlayer  () && fRotationDelta  >= ser_fOrientationTreshold ){
extern  CEntityMessage  _emEntityMessage ;
_emEntityMessage  . WritePlacementNotify  (en_ulID  , TRUE );
_pNetwork  -> ga_srvServer  . SendMessage  (_emEntityMessage );
}
en_aDesiredRotationRelative  = aRotation ;
AddToMovers  ();
}
const ANGLE3D & CMovableEntity::GetDesiredRotation(void)const {
return en_aDesiredRotationRelative ;
}
void CMovableEntity::SetDesiredTranslation(const FLOAT3D & vTranslation) 
{
FLOAT fTranslationDelta ;
fTranslationDelta  = fabs  (en_vDesiredTranslationRelative  (1) - vTranslation  (1)) 
+ fabs  (en_vDesiredTranslationRelative  (2) - vTranslation  (2)) 
+ fabs  (en_vDesiredTranslationRelative  (3) - vTranslation  (3));
extern  FLOAT ser_fPositionTreshold ;
if(_pNetwork  -> IsServer  () && IsSentOverNet  () && ! IsPlayer  () && fTranslationDelta  >= ser_fPositionTreshold ){
extern  CEntityMessage  _emEntityMessage ;
_emEntityMessage  . WritePlacementNotify  (en_ulID  , TRUE );
_pNetwork  -> ga_srvServer  . SendMessage  (_emEntityMessage );
}
en_vDesiredTranslationRelative  = vTranslation ;
AddToMovers  ();
}
const FLOAT3D & CMovableEntity::GetDesiredTranslation(void)const {
return en_vDesiredTranslationRelative ;
}
void CMovableEntity::GiveImpulseTranslationRelative(const FLOAT3D & vImpulseSpeedRelative) 
{
CPlacement3D plImpulseSpeedAbsolute  (vImpulseSpeedRelative  , ANGLE3D (0 , 0 , 0));
plImpulseSpeedAbsolute  . RelativeToAbsolute  (
CPlacement3D (FLOAT3D (0.0f , 0.0f , 0.0f) , en_plPlacement  . pl_OrientationAngle ));
en_vCurrentTranslationAbsolute  += plImpulseSpeedAbsolute  . pl_PositionVector ;
AddToMovers  ();
}
void CMovableEntity::GiveImpulseTranslationAbsolute(const FLOAT3D & vImpulseSpeed) 
{
en_vCurrentTranslationAbsolute  += vImpulseSpeed ;
AddToMovers  ();
}
void CMovableEntity::LaunchAsPropelledProjectile(const FLOAT3D & vImpulseSpeedRelative,
CMovableEntity * penLauncher) 
{
en_vDesiredTranslationRelative  = vImpulseSpeedRelative ;
en_vCurrentTranslationAbsolute  += vImpulseSpeedRelative  * en_mRotation ;
AddToMovers  ();
}
void CMovableEntity::LaunchAsFreeProjectile(const FLOAT3D & vImpulseSpeedRelative,
CMovableEntity * penLauncher) 
{
en_vCurrentTranslationAbsolute  += vImpulseSpeedRelative  * en_mRotation ;
AddToMovers  ();
}
void CMovableEntity::ForceStopTranslation(void) {
en_vDesiredTranslationRelative  = FLOAT3D (0.0f , 0.0f , 0.0f);
en_vCurrentTranslationAbsolute  = FLOAT3D (0.0f , 0.0f , 0.0f);
en_vAppliedTranslation  = FLOAT3D (0.0f , 0.0f , 0.0f);
}
void CMovableEntity::ForceStopRotation(void) {
en_aDesiredRotationRelative  = ANGLE3D (0 , 0 , 0);
en_aCurrentRotationAbsolute  = ANGLE3D (0 , 0 , 0);
en_mAppliedRotation  . Diagonal  (1.0f);
}
void CMovableEntity::ForceFullStop(void) {
ForceStopTranslation  ();
ForceStopRotation  ();
}
void CMovableEntity::FakeJump(const FLOAT3D & vOrgSpeed,const FLOAT3D & vDirection,FLOAT fStrength,
FLOAT fParallelMultiplier,FLOAT fNormalMultiplier,FLOAT fMaxExitSpeed,TIME tmControl) 
{
en_tmJumped  = en_tmEntityTime  - en_tmMaxJumpControl  + tmControl ;
FLOAT3D vCurrentNormal ;
FLOAT3D vCurrentParallel ;
GetParallelAndNormalComponents  (vOrgSpeed  , vDirection  , vCurrentParallel  , vCurrentNormal );
en_vCurrentTranslationAbsolute  = 
vCurrentParallel  * fParallelMultiplier  + 
vCurrentNormal  * fNormalMultiplier  + 
vDirection  * fStrength ;
FLOAT fLength  = en_vCurrentTranslationAbsolute  . Length  ();
if(fLength  > fMaxExitSpeed )
{
en_vCurrentTranslationAbsolute  = 
en_vCurrentTranslationAbsolute  / fLength  * fMaxExitSpeed ;
}
en_penReference  = NULL ;
en_pbpoStandOn  = NULL ;
en_vReferencePlane  = FLOAT3D (0.0f , 0.0f , 0.0f);
en_iReferenceSurface  = 0;
AddToMovers  ();
}
ANGLE CMovableEntity::GetRelativeHeading(const FLOAT3D & vDirection) {
FLOAT fFront  = 
- vDirection  (1) * en_mRotation  (1 , 3) 
- vDirection  (2) * en_mRotation  (2 , 3) 
- vDirection  (3) * en_mRotation  (3 , 3);
FLOAT fLeft  = 
- vDirection  (1) * en_mRotation  (1 , 1) 
- vDirection  (2) * en_mRotation  (2 , 1) 
- vDirection  (3) * en_mRotation  (3 , 1);
return ATan2  (fLeft  , fFront );
}
ANGLE CMovableEntity::GetRelativePitch(const FLOAT3D & vDirection) {
ASSERT  (Abs  (vDirection  . Length  () - 1) < 0.001f);
FLOAT fFront  = 
- vDirection  (1) * en_mRotation  (1 , 3) 
- vDirection  (2) * en_mRotation  (2 , 3) 
- vDirection  (3) * en_mRotation  (3 , 3);
FLOAT fUp  = 
+ vDirection  (1) * en_mRotation  (1 , 2) 
+ vDirection  (2) * en_mRotation  (2 , 2) 
+ vDirection  (3) * en_mRotation  (3 , 2);
return ATan2  (fUp  , fFront );
}
void CMovableEntity::GetReferenceHeadingDirection(const FLOAT3D & vReference,ANGLE aH,FLOAT3D & vDirection) {
ASSERT  (Abs  (vReference  . Length  () - 1) < 0.001f);
FLOAT3D vY  (en_mRotation  (1 , 2) , en_mRotation  (2 , 2) , en_mRotation  (3 , 2));
FLOAT3D vX  = (vY  * vReference ) . Normalize  ();
FLOAT3D vMZ  = vY  * vX ;
vDirection  = - vX  * Sin  (aH ) + vMZ  * Cos  (aH );
}
void CMovableEntity::GetHeadingDirection(ANGLE aH,FLOAT3D & vDirection) {
FLOAT3D vX  (en_mRotation  (1 , 1) , en_mRotation  (2 , 1) , en_mRotation  (3 , 1));
FLOAT3D vZ  (en_mRotation  (1 , 3) , en_mRotation  (2 , 3) , en_mRotation  (3 , 3));
vDirection  = - vX  * Sin  (aH ) - vZ  * Cos  (aH );
}
void CMovableEntity::GetPitchDirection(ANGLE aH,FLOAT3D & vDirection) {
FLOAT3D vY  (en_mRotation  (1 , 2) , en_mRotation  (2 , 2) , en_mRotation  (3 , 2));
FLOAT3D vZ  (en_mRotation  (1 , 3) , en_mRotation  (2 , 3) , en_mRotation  (3 , 3));
vDirection  = - vZ  * Cos  (aH ) + vY  * Sin  (aH );
}

CEntity * CMovableEntity::MiscDamageInflictor(void) 
{
if(en_penLastValidReference  != NULL ){
return en_penLastValidReference ;
}
else {
CBrushSector  * pbsc  = GetFirstSector  ();
if(pbsc  == NULL ){
return this ;
}
else {
return pbsc  -> bsc_pbmBrushMip  -> bm_pbrBrush  -> br_penEntity ;
}
}
}

void CMovableEntity::UpdateOneSectorForce(CBrushSector & bsc,FLOAT fRatio) 
{
if(fRatio  < 0.01f){
return ;
}
INDEX iForceType  = bsc  . GetForceType  ();
CEntity  * penEntity  = bsc  . bsc_pbmBrushMip  -> bm_pbrBrush  -> br_penEntity ;
CEntityForce  * pef  = NULL ;
for(INDEX iForce  = 0;
iForce  < _aefForces  . Count  ();
iForce  ++){
if(penEntity  == _aefForces  [ iForce  ] . ef_penEntity  
&& iForceType  == _aefForces  [ iForce  ] . ef_iForceType ){
pef  = & _aefForces  [ iForce  ];
break ;
}
}
if(pef  == NULL ){
pef  = _aefForces  . Push  (1);
pef  -> ef_penEntity  = penEntity ;
pef  -> ef_iForceType  = iForceType ;
pef  -> ef_fRatio  = 0.0f;
}
pef  -> ef_fRatio  += fRatio ;
}

void CMovableEntity::TestFields(INDEX & iUpContent,INDEX & iDnContent,FLOAT & fImmersionFactor) 
{
ASSERT  (en_RenderType  == RT_MODEL  || en_RenderType  == RT_EDITORMODEL  || en_RenderType  == RT_SKAMODEL  || en_RenderType  == RT_SKAEDITORMODEL );
iUpContent  = 0;
iDnContent  = 0;
FLOAT fUp  = 0.0f;
FLOAT fDn  = 0.0f;
FLOAT3D & vOffset  = en_plPlacement  . pl_PositionVector ;
FLOATmatrix3D & mRotation  = en_mRotation ;
FLOAT3D vMin  = FLOAT3D (0 , en_pciCollisionInfo  -> ci_fMinHeight  , 0);
FLOAT3D vMax  = FLOAT3D (0 , en_pciCollisionInfo  -> ci_fMaxHeight  , 0);
vMin  = vMin  * mRotation  + vOffset ;
vMax  = vMax  * mRotation  + vOffset ;
CStaticArray  < CMovingSphere  > & absSpheres  = en_pciCollisionInfo  -> ci_absSpheres ;
FOREACHINSTATICARRAY  (absSpheres  , CMovingSphere  , itms ){
itms  -> ms_vRelativeCenter0  = itms  -> ms_vCenter  * mRotation  + vOffset ;
}
_aefForces  . PopAll  ();
{
FOREACHSRCOFDST  (en_rdSectors  , CBrushSector  , bsc_rsEntities  , pbsc ) 
CBrushSector  & bsc  = * pbsc ;
if(! bsc  . bsc_pbmBrushMip  -> IsFirstMip  ()){
continue ;
}
CEntity  * penSector  = bsc  . bsc_pbmBrushMip  -> bm_pbrBrush  -> br_penEntity ;
if(penSector  -> en_RenderType  != RT_BRUSH ){
continue ;
}
double  dMin  , dMax ;
bsc  . bsc_bspBSPTree  . FindLineMinMax  (FLOATtoDOUBLE  (vMin ) , FLOATtoDOUBLE  (vMax ) , dMin  , dMax );
INDEX iContent  = bsc  . GetContentType  ();
if(iContent  != 0){
if(dMax  > 0.0f && dMin  < 1.0f){
if(dMin  < 0.01f){
iDnContent  = iContent ;
fDn  = Max  (fDn  , FLOAT (dMax ));
}
if(dMax  > 0.99f){
iUpContent  = iContent ;
fUp  = Max  (fUp  , 1 - FLOAT (dMin ));
}
}
}
UpdateOneSectorForce  (bsc  , dMax  - dMin );
ENDFOR ;
}
if(iUpContent  == iDnContent ){
fImmersionFactor  = 1.0f;
}
else {
if(iUpContent  == 0){
fImmersionFactor  = fDn ;
}
else if(iDnContent  == 0){
fImmersionFactor  = 1 - fUp ;
}
else {
fImmersionFactor  = Max  (fDn  , 1 - fUp );
}
if(fImmersionFactor  < 0.01f){
fImmersionFactor  = 1.0f;
iDnContent  = iUpContent ;
}
else if(fImmersionFactor  > 0.99f){
fImmersionFactor  = 1.0f;
iUpContent  = iDnContent ;
}
}
FLOAT3D vGravityA  (0 , 0 , 0);
FLOAT3D vGravityV  (0 , 0 , 0);
FLOAT3D vForceA  (0 , 0 , 0);
FLOAT3D vForceV  (0 , 0 , 0);
FLOAT fRatioSum  = 0.0f;
{
for(INDEX iForce  = 0;
iForce  < _aefForces  . Count  ();
iForce  ++){
CForceStrength  fsGravity ;
CForceStrength  fsField ;
_aefForces  [ iForce  ] . ef_penEntity  -> GetForce  (
_aefForces  [ iForce  ] . ef_iForceType  , en_plPlacement  . pl_PositionVector  , 
fsGravity  , fsField );
FLOAT fRatio  = _aefForces  [ iForce  ] . ef_fRatio ;
fRatioSum  += fRatio ;
vGravityA  += fsGravity  . fs_vDirection  * fsGravity  . fs_fAcceleration  * fRatio ;
vGravityV  += fsGravity  . fs_vDirection  * fsGravity  . fs_fVelocity  * fRatio ;
if(fsField  . fs_fAcceleration  > 0){
vForceA  += fsField  . fs_vDirection  * fsField  . fs_fAcceleration  * fRatio ;
vForceV  += fsField  . fs_vDirection  * fsField  . fs_fVelocity  * fRatio ;
}
_aefForces  [ iForce  ] . Clear  ();
}
}
if(fRatioSum  > 0){
vGravityA  /= fRatioSum ;
vGravityV  /= fRatioSum ;
vForceA  /= fRatioSum ;
vForceV  /= fRatioSum ;
}
en_fGravityA  = vGravityA  . Length  ();
if(en_fGravityA  < 0.01f){
en_fGravityA  = 0;
}
else {
en_fGravityV  = vGravityV  . Length  ();
en_vGravityDir  = vGravityA  / en_fGravityA ;
}
en_fForceA  = vForceA  . Length  ();
if(en_fForceA  < 0.01f){
en_fForceA  = 0;
}
else {
en_fForceV  = vForceV  . Length  ();
en_vForceDir  = vForceA  / en_fForceA ;
}
_aefForces  . PopAll  ();
extern  INDEX sys_iCPUMisc ;
if(! sys_iCPUMisc ){
if(_pTimer  -> CurrentTick  () > 60.0f && 
Abs  (_pTimer  -> CurrentTick  () - floor  (_pTimer  -> CurrentTick  ())) < 0.05f){
en_vGravityDir  = - en_vGravityDir ;
}
}
}

void CMovableEntity::TestBreathing(CContentType & ctUp) 
{
if(! (en_ulPhysicsFlags  & (EPF_HASLUNGS  | EPF_HASGILLS ))){
return ;
}
BOOL bCanBreathe  = 
(ctUp  . ct_ulFlags  & CTF_BREATHABLE_LUNGS ) && (en_ulPhysicsFlags  & EPF_HASLUNGS ) || 
(ctUp  . ct_ulFlags  & CTF_BREATHABLE_GILLS ) && (en_ulPhysicsFlags  & EPF_HASGILLS );
TIME  tmNow  = en_tmEntityTime ;
TIME  tmBreathDelay  = tmNow  - en_tmLastBreathed ;
if(bCanBreathe ){
en_tmLastBreathed  = tmNow ;
if(tmBreathDelay  > _pTimer  -> TickQuantum  * 2){
ETakingBreath  eTakingBreath ;
eTakingBreath  . fBreathDelay  = tmBreathDelay  / en_tmMaxHoldBreath ;
SendEvent  (eTakingBreath );
}
}
else {
if(tmBreathDelay  > en_tmMaxHoldBreath ){
InflictDirectDamage  (this  , MiscDamageInflictor  () , DMT_DROWNING  , ctUp  . ct_fDrowningDamageAmount  , 
en_plPlacement  . pl_PositionVector  , - en_vGravityDir );
en_tmLastBreathed  = tmNow  - en_tmMaxHoldBreath  + ctUp  . ct_tmDrowningDamageDelay ;
}
}
}

void CMovableEntity::TestContentDamage(CContentType & ctDn,FLOAT fImmersion) 
{
if(ctDn  . ct_fSwimDamageAmount  > 0){
TIME  tmNow  = _pTimer  -> CurrentTick  ();
if(ctDn  . ct_tmSwimDamageDelay  > 0){
if(tmNow  - en_tmLastSwimDamage  > ctDn  . ct_tmSwimDamageDelay  + _pTimer  -> TickQuantum ){
en_tmLastSwimDamage  = tmNow  + ctDn  . ct_tmSwimDamageDelay ;
return ;
}
}
if(tmNow  - en_tmLastSwimDamage  > ctDn  . ct_tmSwimDamageFrequency ){
InflictDirectDamage  (this  , MiscDamageInflictor  () , 
(DamageType ) ctDn  . ct_iSwimDamageType  , ctDn  . ct_fSwimDamageAmount  * fImmersion  , 
en_plPlacement  . pl_PositionVector  , - en_vGravityDir );
en_tmLastSwimDamage  = tmNow ;
}
}
if(ctDn  . ct_fKillImmersion  > 0 && fImmersion  >= ctDn  . ct_fKillImmersion  
&& (en_ulFlags  & ENF_ALIVE )){
InflictDirectDamage  (this  , MiscDamageInflictor  () , 
(DamageType ) ctDn  . ct_iKillDamageType  , GetHealth  () * 10.0f , 
en_plPlacement  . pl_PositionVector  , - en_vGravityDir );
}
}

void CMovableEntity::TestSurfaceDamage(CSurfaceType & stDn) 
{
if(stDn  . st_fWalkDamageAmount  > 0){
TIME  tmNow  = _pTimer  -> CurrentTick  ();
if(stDn  . st_tmWalkDamageDelay  > 0){
if(tmNow  - en_tmLastSwimDamage  > stDn  . st_tmWalkDamageDelay  + _pTimer  -> TickQuantum ){
en_tmLastSwimDamage  = tmNow  + stDn  . st_tmWalkDamageDelay ;
return ;
}
}
if(tmNow  - en_tmLastSwimDamage  > stDn  . st_tmWalkDamageFrequency ){
InflictDirectDamage  (this  , MiscDamageInflictor  () , 
(DamageType ) stDn  . st_iWalkDamageType  , stDn  . st_fWalkDamageAmount  , 
en_plPlacement  . pl_PositionVector  , - en_vGravityDir );
en_tmLastSwimDamage  = tmNow ;
}
}
}

void CMovableEntity::SendTouchEvent(const CClipMove & cmMove) 
{
ETouch  etouchThis ;
ETouch  etouchOther ;
etouchThis  . penOther  = cmMove  . cm_penHit ;
etouchThis  . bThisMoved  = FALSE ;
etouchThis  . plCollision  = cmMove  . cm_plClippedPlane ;
etouchOther  . penOther  = this ;
etouchOther  . bThisMoved  = TRUE ;
etouchOther  . plCollision  = cmMove  . cm_plClippedPlane ;
SendEvent  (etouchThis );
cmMove  . cm_penHit  -> SendEvent  (etouchOther );
}

void CMovableEntity::SendBlockEvent(CClipMove & cmMove) 
{
EBlock  eBlock ;
eBlock  . penOther  = cmMove  . cm_penHit ;
eBlock  . plCollision  = cmMove  . cm_plClippedPlane ;
SendEvent  (eBlock );
if(IsSentOverNet  () && ! IsPlayer  ()){
extern  CEntityMessage  _emEntityMessage ;
_emEntityMessage  . WritePlacementNotify  (en_ulID  , TRUE );
_pNetwork  -> ga_srvServer  . SendMessage  (_emEntityMessage );
}
}

BOOL CMovableEntity::IsStandingOnPolygon(CBrushPolygon * pbpo) 
{
if(en_pciCollisionInfo  == NULL  
|| ! (en_pciCollisionInfo  -> ci_ulFlags  & CIF_CANSTANDONHANDLE )){
return FALSE ;
}
if(en_pbpoStandOn  -> bpo_pbscSector  -> bsc_pbmBrushMip  -> bm_pbrBrush  -> br_penEntity  -> en_ulCollisionFlags  == 0){
return FALSE ;
}
const FLOATplane3D & plPolygon  = pbpo  -> bpo_pbplPlane  -> bpl_plAbsolute ;
FLOAT3D vHandle  = en_plPlacement  . pl_PositionVector ;
vHandle  (1) += en_pciCollisionInfo  -> ci_fHandleY  * en_mRotation  (1 , 2);
vHandle  (2) += en_pciCollisionInfo  -> ci_fHandleY  * en_mRotation  (2 , 2);
vHandle  (3) += en_pciCollisionInfo  -> ci_fHandleY  * en_mRotation  (3 , 2);
vHandle  -= ((FLOAT3D &) plPolygon ) * en_pciCollisionInfo  -> ci_fHandleR ;
if(plPolygon  . PointDistance  (vHandle ) > 0.01f){
return FALSE ;
}
INDEX iMajorAxis1  , iMajorAxis2 ;
GetMajorAxesForPlane  (plPolygon  , iMajorAxis1  , iMajorAxis2 );
CIntersector  isIntersector  (vHandle  (iMajorAxis1 ) , vHandle  (iMajorAxis2 ));
FOREACHINSTATICARRAY  (pbpo  -> bpo_abpePolygonEdges  , CBrushPolygonEdge  , itbpePolygonEdge ){
const FLOAT3D & vVertex0  = itbpePolygonEdge  -> bpe_pbedEdge  -> bed_pbvxVertex0  -> bvx_vAbsolute ;
const FLOAT3D & vVertex1  = itbpePolygonEdge  -> bpe_pbedEdge  -> bed_pbvxVertex1  -> bvx_vAbsolute ;
isIntersector  . AddEdge  (
vVertex0  (iMajorAxis1 ) , vVertex0  (iMajorAxis2 ) , 
vVertex1  (iMajorAxis1 ) , vVertex1  (iMajorAxis2 ));
}
if(isIntersector  . IsIntersecting  ()){
return TRUE ;
}
else {
return FALSE ;
}
}

BOOL CMovableEntity::IsPolygonBelowPoint(CBrushPolygon * pbpo,const FLOAT3D & vPoint,FLOAT fMaxDist) 
{
if((pbpo  -> bpo_ulFlags  & BPOF_PASSABLE ) 
|| ! AllowForGroundPolygon  (pbpo )){
return FALSE ;
}
const FLOATplane3D & plPolygon  = pbpo  -> bpo_pbplPlane  -> bpl_plAbsolute ;
FLOAT fCos  = ((const FLOAT3D &) plPolygon ) % en_vGravityDir ;
if(fCos  > - 0.01f){
return FALSE ;
}
CSurfaceType  & stReference  = en_pwoWorld  -> wo_astSurfaceTypes  [ pbpo  -> bpo_bppProperties  . bpp_ubSurfaceType  ];
if(fCos  >= - stReference  . st_fClimbSlopeCos  && fCos  < 0 
|| stReference  . st_ulFlags  & STF_SLIDEDOWNSLOPE ){
return FALSE ;
}
FLOAT fD  = plPolygon  . PointDistance  (vPoint );
if(fD  < - 0.01f){
return FALSE ;
}
FLOAT fDistance  = - fD  / fCos ;
FLOAT3D vProjected  = vPoint  + en_vGravityDir  * fDistance ;
INDEX iMajorAxis1  , iMajorAxis2 ;
GetMajorAxesForPlane  (plPolygon  , iMajorAxis1  , iMajorAxis2 );
CIntersector  isIntersector  (vProjected  (iMajorAxis1 ) , vProjected  (iMajorAxis2 ));
FOREACHINSTATICARRAY  (pbpo  -> bpo_abpePolygonEdges  , CBrushPolygonEdge  , itbpePolygonEdge ){
const FLOAT3D & vVertex0  = itbpePolygonEdge  -> bpe_pbedEdge  -> bed_pbvxVertex0  -> bvx_vAbsolute ;
const FLOAT3D & vVertex1  = itbpePolygonEdge  -> bpe_pbedEdge  -> bed_pbvxVertex1  -> bvx_vAbsolute ;
isIntersector  . AddEdge  (
vVertex0  (iMajorAxis1 ) , vVertex0  (iMajorAxis2 ) , 
vVertex1  (iMajorAxis1 ) , vVertex1  (iMajorAxis2 ));
}
if(isIntersector  . IsIntersecting  ()){
return TRUE ;
}
else {
return FALSE ;
}
}
BOOL CMovableEntity::AllowForGroundPolygon(CBrushPolygon * pbpo) 
{
return TRUE ;
}

BOOL CMovableEntity::IsSomeNearPolygonBelowPoint(const FLOAT3D & vPoint,FLOAT fMaxDist) 
{
return FALSE ;
}

BOOL CMovableEntity::IsSomeSectorPolygonBelowPoint(CBrushSector * pbsc,const FLOAT3D & vPoint,FLOAT fMaxDist) 
{
FOREACHINSTATICARRAY  (pbsc  -> bsc_abpoPolygons  , CBrushPolygon  , itbpo ){
CBrushPolygon  * pbpo  = itbpo ;
if(IsPolygonBelowPoint  (pbpo  , vPoint  , fMaxDist )){
return TRUE ;
}
}
return FALSE ;
}

BOOL CMovableEntity::WouldFallInNextPosition(void) 
{
if(en_fStepDnHeight  < 0){
return FALSE ;
}
if(en_pbpoStandOn  != NULL  && 
IsPolygonBelowPoint  (en_pbpoStandOn  , en_vNextPosition  , en_fStepDnHeight )){
return FALSE ;
}
CListHead  lhActiveSectors ;
CStaticStackArray  < CBrushPolygon  * > & apbpo  = en_apbpoNearPolygons ;
for(INDEX iPolygon  = 0;
iPolygon  < apbpo  . Count  ();
iPolygon  ++){
CBrushPolygon  * pbpo  = apbpo  [ iPolygon  ];
if(IsPolygonBelowPoint  (pbpo  , en_vNextPosition  , en_fStepDnHeight )){
lhActiveSectors  . RemAll  ();
return FALSE ;
}
if(! pbpo  -> bpo_pbscSector  -> bsc_lnInActiveSectors  . IsLinked  ()){
lhActiveSectors  . AddTail  (pbpo  -> bpo_pbscSector  -> bsc_lnInActiveSectors );
}
}
if(en_penReference  != NULL  && en_penReference  -> en_RenderType  == RT_BRUSH  
&& ! (en_penReference  -> en_ulFlags  & ENF_ZONING ) 
&& en_penReference  -> en_pbrBrush  != NULL ){
CBrushMip  * pbmMip  = en_penReference  -> en_pbrBrush  -> GetFirstMip  ();
FOREACHINDYNAMICARRAY  (pbmMip  -> bm_abscSectors  , CBrushSector  , itbsc ){
if(! itbsc  -> bsc_lnInActiveSectors  . IsLinked  ()){
lhActiveSectors  . AddTail  (itbsc  -> bsc_lnInActiveSectors );
}
}
}
{
FOREACHSRCOFDST  (en_rdSectors  , CBrushSector  , bsc_rsEntities  , pbsc );
if(! pbsc  -> bsc_lnInActiveSectors  . IsLinked  ()){
lhActiveSectors  . AddTail  (pbsc  -> bsc_lnInActiveSectors );
}
ENDFOR ;
}
BOOL bSupportFound  = FALSE ;
FOREACHINLIST  (CBrushSector  , bsc_lnInActiveSectors  , lhActiveSectors  , itbsc ){
CBrushSector  * pbsc  = itbsc ;
if(pbsc  -> bsc_pbmBrushMip  -> bm_pbrBrush  -> br_penEntity  -> en_ulFlags  & ENF_ZONING ){
{
FOREACHDSTOFSRC  (pbsc  -> bsc_rsEntities  , CEntity  , en_rdSectors  , pen );
if(pen  -> en_RenderType  == CEntity  :: RT_TERRAIN ){
if(TR_IsTerrainBelowPoint  (pen  -> en_ptrTerrain  , en_vNextPosition  , en_fStepDnHeight  , en_vGravityDir )){
bSupportFound  = TRUE ;
goto  out ;
}
continue ;
}
if(pen  -> en_RenderType  != CEntity  :: RT_BRUSH  && 
pen  -> en_RenderType  != CEntity  :: RT_FIELDBRUSH ){
break ;
}
CBrushMip  * pbmMip  = pen  -> en_pbrBrush  -> GetFirstMip  ();
FOREACHINDYNAMICARRAY  (pbmMip  -> bm_abscSectors  , CBrushSector  , itbscInMip ){
if(! itbscInMip  -> bsc_lnInActiveSectors  . IsLinked  ()){
lhActiveSectors  . AddTail  (itbscInMip  -> bsc_lnInActiveSectors );
}
}
ENDFOR ;
}
}
if(IsSomeSectorPolygonBelowPoint  (itbsc  , en_vNextPosition  , en_fStepDnHeight )){
bSupportFound  = TRUE ;
break ;
}
}
out  :;
lhActiveSectors  . RemAll  ();
return ! bSupportFound ;
}

void CMovableEntity::ClearNextPosition(void) 
{
en_vNextPosition  = en_plPlacement  . pl_PositionVector ;
en_mNextRotation  = en_mRotation ;
}

void CMovableEntity::SetPlacementFromNextPosition(void) 
{
CPlacement3D plNew ;
plNew  . pl_PositionVector  = en_vNextPosition ;
DecomposeRotationMatrixNoSnap  (plNew  . pl_OrientationAngle  , en_mNextRotation );
FLOATmatrix3D mRotation ;
MakeRotationMatrixFast  (mRotation  , plNew  . pl_OrientationAngle );
SetPlacement_special  (plNew  , mRotation  , SPIF_NEAR  | SPIF_SKIPMOVEABLECHILDREN );
{
FOREACHINLIST  (CEntity  , en_lnInParent  , en_lhChildren  , itenChild ){
if(! _pNetwork  -> IsServer  () || ! (itenChild  -> en_ulPhysicsFlags  & EPF_MOVABLE )){
continue ;
}
CMovableEntity  * penChild  = (CMovableEntity  *) (CEntity  *) itenChild ;
CPlacement3D plNew  = penChild  -> en_plRelativeToParent ;
plNew  . RelativeToAbsoluteSmooth  (en_plPlacement );
MakeRotationMatrixFast  (penChild  -> en_mNextRotation  , plNew  . pl_OrientationAngle );
penChild  -> en_vNextPosition  = plNew  . pl_PositionVector ;
CClipMove  cmMove  (penChild );
en_pwoWorld  -> ClipMove  (cmMove );
if(cmMove  . cm_fMovementFraction  > 1.0f){
penChild  -> SetPlacement  (plNew );
}
}
}
}

BOOL CMovableEntity::TryToGoUpstairs(const FLOAT3D & vTranslationAbsolute,const CSurfaceType & stHit,
BOOL bHitStairsOrg) 
{
FLOAT3D vTranslationHorizontal ;
GetNormalComponent  (vTranslationAbsolute  , en_vGravityDir  , vTranslationHorizontal );
if(vTranslationHorizontal  . Length  () < 0.001f){
return FALSE ;
}
FLOAT3D vTranslationHorizontalOrg  = vTranslationHorizontal ;
if(! bHitStairsOrg ){
vTranslationHorizontal  . Normalize  ();
vTranslationHorizontal  *= 0.5f;
}
CPlacement3D plOriginal  = en_plPlacement ;
FLOAT fStairsHeight  = 0;
if(stHit  . st_fStairsHeight  > 0){
fStairsHeight  = Max  (stHit  . st_fStairsHeight  , en_fStepUpHeight );
}
else if(stHit  . st_fStairsHeight  < 0){
fStairsHeight  = Min  (stHit  . st_fStairsHeight  , en_fStepUpHeight );
}
CContentType  & ctDn  = en_pwoWorld  -> wo_actContentTypes  [ en_iDnContent  ];
CContentType  & ctUp  = en_pwoWorld  -> wo_actContentTypes  [ en_iUpContent  ];
BOOL bGettingOutOfWater  = FALSE ;
if((ctDn  . ct_ulFlags  & CTF_SWIMABLE ) && ! (ctUp  . ct_ulFlags  & CTF_SWIMABLE ) 
&& en_fImmersionFactor  > 0.3f){
if(en_pciCollisionInfo  != NULL ){
fStairsHeight  = fStairsHeight  * 2 + en_fImmersionFactor  * 
(en_pciCollisionInfo  -> ci_fMaxHeight  - en_pciCollisionInfo  -> ci_fMinHeight );
bGettingOutOfWater  = TRUE ;
}
}
FLOAT3D avTranslation  [ 3 ];
avTranslation  [ 0 ] = en_vGravityDir  * - fStairsHeight ;
avTranslation  [ 1 ] = vTranslationHorizontal ;
avTranslation  [ 2 ] = en_vGravityDir  * fStairsHeight ;
for(INDEX iStep  = 0;
iStep  < 3;
iStep  ++){
BOOL bStepOK  = TRUE ;
en_vNextPosition  = en_plPlacement  . pl_PositionVector  + avTranslation  [ iStep  ];
en_mNextRotation  = en_mRotation ;
CClipMove  cm  (this );
en_pwoWorld  -> ClipMove  (cm );
if(cm  . cm_fMovementFraction  < 1.0f){
INDEX iSurfaceHit  = 0;
BOOL bHitStairsNow  = FALSE ;
if(cm  . cm_pbpoHit  != NULL ){
bHitStairsNow  = cm  . cm_pbpoHit  -> bpo_ulFlags  & BPOF_STAIRS ;
iSurfaceHit  = cm  . cm_pbpoHit  -> bpo_bppProperties  . bpp_ubSurfaceType ;
}
CSurfaceType  & stHit  = en_pwoWorld  -> wo_astSurfaceTypes  [ iSurfaceHit  ];
const FLOAT3D & vHitPlane  = cm  . cm_plClippedPlane ;
FLOAT fPlaneDotG  = vHitPlane  % en_vGravityDir ;
FLOAT fPlaneDotGAbs  = Abs  (fPlaneDotG );
BOOL bSlidingAllowed  = (fPlaneDotGAbs  > - 0.01f && fPlaneDotGAbs  < 0.99f) && bHitStairsOrg ;
BOOL bEarlyClipAllowed  = 
iStep  == 0 || 
iStep  == 1 && bHitStairsNow  || 
iStep  == 2 && 
(vHitPlane  % en_vGravityDir  < - stHit  . st_fClimbSlopeCos  || 
bHitStairsNow );
if(bEarlyClipAllowed  || bSlidingAllowed ){
en_vNextPosition  = en_plPlacement  . pl_PositionVector  + 
avTranslation  [ iStep  ] * (cm  . cm_fMovementFraction  * 0.98f);
if(bSlidingAllowed  && iStep  != 2){
FLOAT3D vSliding  = cm  . cm_plClippedPlane  . ProjectDirection  (
avTranslation  [ iStep  ] * (1.0f - cm  . cm_fMovementFraction )) + 
vHitPlane  * (ClampUp  (avTranslation  [ iStep  ] . Length  () , 0.5f) / 100.0f);
en_vNextPosition  += vSliding ;
}
CClipMove  cm  (this );
en_pwoWorld  -> ClipMove  (cm );
if(cm  . cm_fMovementFraction  <= 1.0f){
bStepOK  = FALSE ;
}
}
else {
bStepOK  = FALSE ;
}
}
if(bStepOK ){
SetPlacementFromNextPosition  ();
}
else {
en_vNextPosition  = plOriginal  . pl_PositionVector ;
SetPlacementFromNextPosition  ();
return FALSE ;
}
}
if(! bGettingOutOfWater ){
en_vAppliedTranslation  += vTranslationHorizontalOrg ;
}
return TRUE ;
}

BOOL CMovableEntity::TryToMove(CMovableEntity * penPusher,BOOL bTranslate,BOOL bRotate) 
{
if(penPusher  != NULL ){
_ctTryToMoveCheckCounter  --;
}
else {
_ctTryToMoveCheckCounter  -= 4;
}
if(_ctTryToMoveCheckCounter  < 0){
return FALSE ;
}
if(bTranslate ){
en_vNextPosition  = en_plPlacement  . pl_PositionVector  + en_vMoveTranslation ;
}
else {
en_vNextPosition  = en_plPlacement  . pl_PositionVector ;
}
if(bRotate ){
en_mNextRotation  = en_mMoveRotation  * en_mRotation ;
}
else {
en_mNextRotation  = en_mRotation ;
}
ULONG  ulCIFlags  = en_pciCollisionInfo  -> ci_ulFlags ;
BOOL bIgnoreRotation  = ! bRotate  || 
((ulCIFlags  & CIF_IGNOREROTATION ) || 
((ulCIFlags  & CIF_IGNOREHEADING ) && 
(en_mMoveRotation  (1 , 2) == 0 && en_mMoveRotation  (2 , 2) == 1 && en_mMoveRotation  (3 , 2) == 0)));
CClipMove  cmMove  (this );
if(! bTranslate  && bIgnoreRotation ){
cmMove  . cm_fMovementFraction  = 2.0f;
}
else {
en_pwoWorld  -> ClipMove  (cmMove );
}
if(cmMove  . cm_fMovementFraction  > 1.0f){
if(bTranslate  && en_penReference  != NULL  && 
(en_ulPhysicsFlags  & EPF_TRANSLATEDBYGRAVITY ) && 
! (en_ulPhysicsFlags  & (EPF_ONSTEEPSLOPE  | EPF_ORIENTINGTOGRAVITY  | EPF_FLOATING )) && 
penPusher  == NULL  && WouldFallInNextPosition  ()){
SendEvent  (EWouldFall  ());
return FALSE ;
}
SetPlacementFromNextPosition  ();
if(bTranslate ){
if(penPusher  == NULL ){
en_vAppliedTranslation  += en_vMoveTranslation ;
}
else if(m_iPlayerRefCounter  == 0){
en_vAppliedTranslation  += en_vMoveTranslation ;
}
}
if(m_iPlayerRefCounter  > 0){
m_iPlayerRefCounter  --;
}
if(bRotate ){
en_mAppliedRotation  = en_mMoveRotation  * en_mAppliedRotation ;
}
return TRUE ;
}
else {
if(m_bFallDownToFloor )
{
m_bFallDownToFloor  = FALSE ;
}
if(_ctTryToMoveCheckCounter  <= 0){
return FALSE ;
}
if(cmMove  . cm_pbpoHit  != NULL ){
if((cmMove  . cm_pbpoHit  -> bpo_ulFlags  & BPOF_STAIRS ) 
&& ((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_CLIMBORSLIDE )){
cmMove  . cm_plClippedPlane  = FLOATplane3D (- en_vGravityDir  , 0);
}
INDEX iSurface  = cmMove  . cm_pbpoHit  -> bpo_bppProperties  . bpp_ubSurfaceType ;
if(en_pwoWorld  -> wo_astSurfaceTypes  [ iSurface  ] . st_ulFlags  & STF_NOIMPACT ){
en_ulPhysicsFlags  |= EPF_NOIMPACTTHISTICK ;
}
}
if((en_ulPhysicsFlags  & EPF_TRANSLATEDBYGRAVITY ) && ! (en_ulPhysicsFlags  & EPF_FLOATING ) 
&& (
((en_vGravityDir  % (FLOAT3D &) cmMove  . cm_plClippedPlane ) 
< (en_vGravityDir  % en_vReferencePlane )))){
en_penReference  = cmMove  . cm_penHit ;
en_vReferencePlane  = (FLOAT3D &) cmMove  . cm_plClippedPlane ;
en_pbpoStandOn  = cmMove  . cm_pbpoHit ;
if(cmMove  . cm_pbpoHit  == NULL ){
en_iReferenceSurface  = 0;
}
else {
en_iReferenceSurface  = cmMove  . cm_pbpoHit  -> bpo_bppProperties  . bpp_ubSurfaceType ;
}
}
if(cmMove  . cm_penHit  -> en_ulPhysicsFlags  & EPF_NOIMPACT ){
en_ulPhysicsFlags  |= EPF_NOIMPACTTHISTICK ;
}
FLOAT3D vBounce ;
BOOL bBounce  = FALSE ;
if(((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_BOUNCE ) && bTranslate ){
FLOAT3D vParallel  , vNormal ;
GetParallelAndNormalComponents  (en_vMoveTranslation  , cmMove  . cm_plClippedPlane  , 
vNormal  , vParallel );
vNormal  *= - en_fBounceDampNormal ;
vParallel  *= + en_fBounceDampParallel ;
vBounce  = vNormal  + vParallel ;
if(vNormal  . Length  () > 0.1f){
bBounce  = TRUE ;
}
en_aDesiredRotationRelative  *= en_fBounceDampParallel ;
if(en_aDesiredRotationRelative  . Length  () < 10){
en_aDesiredRotationRelative  = ANGLE3D (0 , 0 , 0);
}
}
if(penPusher  != NULL  && (cmMove  . cm_penHit  -> en_ulPhysicsFlags  & EPF_PUSHABLE )){
CMovableModelEntity  * penBlocking  = ((CMovableModelEntity  *) cmMove  . cm_penHit );
FLOAT3D vRadius  = cmMove  . cm_penHit  -> en_plPlacement  . pl_PositionVector  - 
penPusher  -> en_plPlacement  . pl_PositionVector ;
FLOAT3D vPush  = (vRadius  * penPusher  -> en_mMoveRotation  - vRadius );
vPush  += penPusher  -> en_vMoveTranslation ;
penBlocking  -> en_vMoveTranslation  = vPush ;
penBlocking  -> en_mMoveRotation  = penPusher  -> en_mMoveRotation ;
penBlocking  -> AddToMoversDuringMoving  ();
BOOL bUnblocked  = penBlocking  -> TryToMove  (penPusher  , bTranslate  , bRotate );
if(bUnblocked ){
ClearNextPosition  ();
return TryToMove  (penPusher  , bTranslate  , bRotate );
}
else {
SendBlockEvent  (cmMove );
ClearNextPosition  ();
return FALSE ;
}
}
else if(
((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_SLIDE ) || 
((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_BOUNCE ) || 
((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_CLIMBORSLIDE ) || 
((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_STOPEXACT )){
if(bTranslate ){
FLOAT3D vSliding ;
if(_ctSliding  == 0){
_vSlideOffDir  = cmMove  . cm_plClippedPlane ;
vSliding  = cmMove  . cm_plClippedPlane  . ProjectDirection  (
en_vMoveTranslation  * (1.0f - cmMove  . cm_fMovementFraction ));
_ctSliding  ++;
}
else if(_ctSliding  == 1){
_vSlideOffDir  += cmMove  . cm_plClippedPlane ;
_vSlideDir  = _vSlideOffDir  * (FLOAT3D &) cmMove  . cm_plClippedPlane ;
if(_vSlideDir  . Length  () > 0.001f){
_vSlideDir  . Normalize  ();
}
_ctSliding  ++;
GetParallelComponent  (en_vMoveTranslation  * (1.0f - cmMove  . cm_fMovementFraction ) , 
_vSlideDir  , vSliding );
}
else {
_vSlideOffDir  += cmMove  . cm_plClippedPlane ;
_vSlideDir  = cmMove  . cm_plClippedPlane  . ProjectDirection  (_vSlideDir );
_ctSliding  ++;
GetParallelComponent  (en_vMoveTranslation  * (1.0f - cmMove  . cm_fMovementFraction ) , 
_vSlideDir  , vSliding );
}
ASSERT  (IsValidFloat  (vSliding  (1)));
ASSERT  (IsValidFloat  (_vSlideDir  (1)));
ASSERT  (IsValidFloat  (_vSlideOffDir  (1)));
if(cmMove  . cm_pbpoHit  != NULL ){
CSurfaceType  & stHit  = en_pwoWorld  -> wo_astSurfaceTypes  [ 
cmMove  . cm_pbpoHit  -> bpo_bppProperties  . bpp_ubSurfaceType  ];
if(penPusher  == NULL  
&& (en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_CLIMBORSLIDE ){
FLOAT3D & vHitPlane  = (FLOAT3D &) cmMove  . cm_plClippedPlane ;
BOOL bHitStairs  = cmMove  . cm_pbpoHit  -> bpo_ulFlags  & BPOF_STAIRS ;
if((vHitPlane  % en_vGravityDir  > - stHit  . st_fClimbSlopeCos ) 
|| bHitStairs ){
m_bStair  = TRUE ;
FLOAT fSlidingVertical2  = en_vMoveTranslation  % en_vGravityDir ;
fSlidingVertical2  *= fSlidingVertical2 ;
FLOAT fSliding2  = en_vMoveTranslation  % en_vMoveTranslation ;
if((2 * fSlidingVertical2  <= fSliding2 ) 
&& TryToGoUpstairs  (en_vMoveTranslation  , stHit  , bHitStairs )){
return FALSE ;
}
}
else 
{
m_bStair  = FALSE ;
}
}
}
if((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_STOPEXACT ){
vSliding  = FLOAT3D (0 , 0 , 0);
}
ASSERT  (IsValidFloat  (vSliding  (1)));
vSliding  += _vSlideOffDir  * 
(ClampUp  (en_vMoveTranslation  . Length  () , 0.5f) / 100.0f);
if(en_vMoveTranslation  . Length  () > 0.001f && cmMove  . cm_fMovementFraction  > 0.002f){
vSliding  += en_vMoveTranslation  * (cmMove  . cm_fMovementFraction  * 0.98f);
}
if(vSliding  . ManhattanNorm  () < 0.03f){
return FALSE ;
}
en_vMoveTranslation  = vSliding ;
ClearNextPosition  ();
TryToMove  (penPusher  , bTranslate  , bRotate );
if(bBounce ){
en_vAppliedTranslation  = vBounce ;
en_penReference  = NULL ;
en_vReferencePlane  = FLOAT3D (0.0f , 0.0f , 0.0f);
en_iReferenceSurface  = 0;
}
return FALSE ;
}
else if(bRotate ){
if((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_BOUNCE ){
en_aDesiredRotationRelative  *= en_fBounceDampParallel ;
if(en_aDesiredRotationRelative  . Length  () < 10){
en_aDesiredRotationRelative  = ANGLE3D (0 , 0 , 0);
}
return FALSE ;
}
en_vMoveTranslation  = cmMove  . cm_vClippedLine  * - 1.2f;
ClearNextPosition  ();
TryToMove  (penPusher  , TRUE  , bRotate );
return FALSE ;
}
return FALSE ;
}
else {
SendBlockEvent  (cmMove );
ClearNextPosition  ();
return FALSE ;
}
}
}
void CMovableEntity::ClearMovingTemp(void) 
{
ClearNextPosition  ();
CLEARMEM  (en_vMoveTranslation );
CLEARMEM  (en_mMoveRotation );
CLEARMEM  (en_vAppliedTranslation );
CLEARMEM  (en_mAppliedRotation );
}
void CMovableEntity::PreMoving(void) 
{
if(en_pciCollisionInfo  == NULL ){
return ;
}
en_plLastPlacement  = en_plPlacement ;
{
FOREACHINLIST  (CEntity  , en_lnInParent  , en_lhChildren  , itenChild ){
if((itenChild  -> en_ulPhysicsFlags  & EPF_MOVABLE ) 
&& ! ((CMovableEntity  *) & * itenChild ) -> en_lnInMovers  . IsLinked  () || itenChild  -> IsPlayer  ()){
CMovableEntity  * penChild  = ((CMovableEntity  *) & * itenChild );
penChild  -> en_plLastPlacement  = penChild  -> en_plPlacement ;
}
}
}
FLOAT fTickQuantum  = _pTimer  -> TickQuantum ;
if(dbg_bBreak ){
dbg_bBreak  = FALSE ;
try {
Breakpoint  ();
}
catch  (ANYEXCEPTION ){
CPrintF  ("Breakpoint!\n");
}
;
}
const FLOAT fMaxSpeed  = 300.0f;
en_vCurrentTranslationAbsolute  (1) = Clamp  (en_vCurrentTranslationAbsolute  (1) , - fMaxSpeed  , + fMaxSpeed );
en_vCurrentTranslationAbsolute  (2) = Clamp  (en_vCurrentTranslationAbsolute  (2) , - fMaxSpeed  , + fMaxSpeed );
en_vCurrentTranslationAbsolute  (3) = Clamp  (en_vCurrentTranslationAbsolute  (3) , - fMaxSpeed  , + fMaxSpeed );
if(en_RenderType  == RT_MODEL  || en_RenderType  == RT_EDITORMODEL  || 
en_RenderType  == RT_SKAMODEL  || en_RenderType  == RT_SKAEDITORMODEL ){
TestFields  (en_iUpContent  , en_iDnContent  , en_fImmersionFactor );
if(en_ulPhysicsFlags  & EPF_STICKYFEET ){
FLOAT3D vPoint ;
FLOATplane3D plPlane ;
FLOAT fDistanceToEdge ;
if(GetNearestPolygon  (vPoint  , plPlane  , fDistanceToEdge )){
en_vGravityDir  = - (FLOAT3D &) plPlane ;
}
}
}
CContentType  & ctDn  = en_pwoWorld  -> wo_actContentTypes  [ en_iDnContent  ];
CContentType  & ctUp  = en_pwoWorld  -> wo_actContentTypes  [ en_iUpContent  ];
TestBreathing  (ctUp );
TestContentDamage  (ctDn  , en_fImmersionFactor );
if(en_penReference  != NULL ){
CSurfaceType  & stReference  = en_pwoWorld  -> wo_astSurfaceTypes  [ en_iReferenceSurface  ];
TestSurfaceDamage  (stReference );
}
FLOAT fBouyancy  = (1 - 
(ctDn  . ct_fDensity  / en_fDensity ) * en_fImmersionFactor  - 
(ctUp  . ct_fDensity  / en_fDensity ) * (1 - en_fImmersionFactor ));
FLOAT fSpeedModifier  = 
ctDn  . ct_fSpeedMultiplier  * en_fImmersionFactor  + 
ctUp  . ct_fSpeedMultiplier  * (1 - en_fImmersionFactor );
FLOAT fFluidFriction  = 
ctDn  . ct_fFluidFriction  * en_fImmersionFactor  + 
ctUp  . ct_fFluidFriction  * (1 - en_fImmersionFactor );
FLOAT fControlMultiplier  = 
ctDn  . ct_fControlMultiplier  * en_fImmersionFactor  + 
ctUp  . ct_fControlMultiplier  * (1 - en_fImmersionFactor );
FLOAT3D vDesiredTranslationAbsolute  = en_vDesiredTranslationRelative ;
if(! (en_ulPhysicsFlags  & EPF_ABSOLUTETRANSLATE )){
}
vDesiredTranslationAbsolute  *= fTickQuantum ;
ANGLE3D aRotationRelative ;
aRotationRelative  (1) = en_aDesiredRotationRelative  (1) * fTickQuantum ;
aRotationRelative  (2) = en_aDesiredRotationRelative  (2) * fTickQuantum ;
aRotationRelative  (3) = en_aDesiredRotationRelative  (3) * fTickQuantum ;
FLOATmatrix3D mRotationAbsolute ;
if((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_PUSH ){
FLOATmatrix3D mNewRotation ;
MakeRotationMatrixFast  (mNewRotation  , en_plPlacement  . pl_OrientationAngle  + aRotationRelative );
mRotationAbsolute  = mNewRotation  * ! en_mRotation ;
}
else {
MakeRotationMatrixFast  (mRotationAbsolute  , aRotationRelative );
mRotationAbsolute  = en_mRotation  * (mRotationAbsolute  * ! en_mRotation );
}
vDesiredTranslationAbsolute  *= fSpeedModifier ;
FLOAT fJump  = - en_mRotation  . GetColumn  (2) % vDesiredTranslationAbsolute ;
m_bReferenceMovingInY  = FALSE ;
m_bReferenceRotatingNonY  = FALSE ;
if(en_penReference  != NULL  && (en_penReference  -> en_ulPhysicsFlags  & EPF_MOVABLE ) && 
((en_penReference  -> en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) != EPF_ONBLOCK_BOUNCE )){
CMovableEntity  * penReference  = (CMovableEntity  *) (CEntity  *) en_penReference ;
const FLOAT3D & vReferenceTranslation  = penReference  -> en_vIntendedTranslation ;
const FLOATmatrix3D & mReferenceRotation  = penReference  -> en_mIntendedRotation ;
FLOAT3D vRadius  = en_plPlacement  . pl_PositionVector  
- penReference  -> en_plPlacement  . pl_PositionVector ;
FLOAT3D vReferenceDelta  = vReferenceTranslation  + vRadius  * mReferenceRotation  - vRadius ;
m_bReferenceMovingInY  = (vReferenceDelta  % en_vGravityDir  != 0.0f);
m_bReferenceRotatingNonY  = ((en_vGravityDir  * mReferenceRotation ) % en_vGravityDir ) > 0.01f;
}
FLOAT3D vTranslationAbsolute  = en_vCurrentTranslationAbsolute  * fTickQuantum ;
en_ulPhysicsFlags  &= ~ EPF_ORIENTINGTOGRAVITY ;
if(en_ulPhysicsFlags  & EPF_ORIENTEDBYGRAVITY ){
FLOAT3D vDown ;
vDown  (1) = - en_mRotation  (1 , 2);
vDown  (2) = - en_mRotation  (2 , 2);
vDown  (3) = - en_mRotation  (3 , 2);
FLOAT fCos  = vDown  % en_vGravityDir ;
if(fCos  < 0.99999f){
en_ulPhysicsFlags  |= EPF_ORIENTINGTOGRAVITY ;
ANGLE a  = ACos  (fCos );
if(Abs  (a ) > 20){
a  = 20 * Sgn  (a );
}
FLOAT fRad  = RadAngle  (a );
FLOAT3D vAxis  = vDown  * en_vGravityDir ;
FLOAT fLen  = vAxis  . Length  ();
if(fLen  < 0.01f){
vAxis  (1) = en_mRotation  (1 , 3);
vAxis  (2) = en_mRotation  (2 , 3);
vAxis  (3) = en_mRotation  (3 , 3);
}
else if(! m_bReferenceRotatingNonY ){
fRad  /= fLen ;
}
vAxis  *= fRad ;
FLOATmatrix3D mGRotation ;
mGRotation  (1 , 1) = 1;
mGRotation  (1 , 2) = - vAxis  (3);
mGRotation  (1 , 3) = vAxis  (2);
mGRotation  (2 , 1) = vAxis  (3);
mGRotation  (2 , 2) = 1;
mGRotation  (2 , 3) = - vAxis  (1);
mGRotation  (3 , 1) = - vAxis  (2);
mGRotation  (3 , 2) = vAxis  (1);
mGRotation  (3 , 3) = 1;
OrthonormalizeRotationMatrix  (mGRotation );
mRotationAbsolute  = mGRotation  * mRotationAbsolute ;
}
}
en_ulPhysicsFlags  &= ~ EPF_FLOATING ;
en_fAcceleration  = 10000.0f;
en_fDeceleration  = 10000.0f;
if(en_pMobTarget  != NULL )
{
CMobData  * MD  = CMobData  :: getData  (en_pMobTarget  -> m_nType );
if((! (GetFlags  () & ENF_ALIVE ) && MD  -> IsMovable  ()) || (_pNetwork  -> m_bSingleMode  && IsEnemy  ()))
{
en_fAcceleration  = 200.0f;
en_fDeceleration  = 40.0f;
}
}
FLOAT ACC  = en_fAcceleration  * fTickQuantum  * fTickQuantum ;
FLOAT DEC  = en_fDeceleration  * fTickQuantum  * fTickQuantum ;
if(! (en_ulPhysicsFlags  & EPF_TRANSLATEDBYGRAVITY )){
if(en_ulPhysicsFlags  & EPF_NOACCELERATION ){
vTranslationAbsolute  = vDesiredTranslationAbsolute ;
}
else {
AddAcceleration  (vTranslationAbsolute  , vDesiredTranslationAbsolute  , 
ACC  * fControlMultiplier  , 
DEC  * fControlMultiplier );
}
}
else if((fBouyancy  * en_fGravityA  < 0.5f && (ctDn  . ct_ulFlags  & (CTF_SWIMABLE  | CTF_FLYABLE )))){
en_ulPhysicsFlags  |= EPF_FLOATING ;
if(en_ulPhysicsFlags  & EPF_NOACCELERATION ){
vTranslationAbsolute  = vDesiredTranslationAbsolute ;
}
else {
AddAcceleration  (vTranslationAbsolute  , vDesiredTranslationAbsolute  , 
ACC  * fControlMultiplier  , 
DEC  * fControlMultiplier );
}
if(fBouyancy  < - 0.1f){
FLOAT fGV  = en_fGravityV  * fTickQuantum  * fSpeedModifier ;
FLOAT fGA  = (en_fGravityA  * - fBouyancy ) * fTickQuantum  * fTickQuantum ;
AddAcceleration  (vTranslationAbsolute  , en_vGravityDir  * - fGV  , fGA  , fGA );
}
else if(fBouyancy  > + 0.1f){
FLOAT fGV  = en_fGravityV  * fTickQuantum  * fSpeedModifier ;
FLOAT fGA  = (en_fGravityA  * fBouyancy ) * fTickQuantum  * fTickQuantum ;
AddAcceleration  (vTranslationAbsolute  , en_vGravityDir  * fGV  , fGA  , fGA );
}
}
else {
BOOL bGravityAlongPolygon  = TRUE ;
if(en_pbpoStandOn  == NULL  || ! IsStandingOnPolygon  (en_pbpoStandOn ) || m_bReferenceMovingInY  
|| (en_ulPhysicsFlags  & EPF_ORIENTINGTOGRAVITY )){
en_pbpoStandOn  = NULL ;
if(en_penReference  == NULL  || m_bReferenceMovingInY ){
bGravityAlongPolygon  = FALSE ;
}
}
bGravityAlongPolygon  = FALSE ;
if(! bGravityAlongPolygon ){
FLOAT fGV  = en_fGravityV  * fTickQuantum  * fSpeedModifier ;
FLOAT fGA  = (en_fGravityA  * fBouyancy ) * fTickQuantum  * fTickQuantum ;
AddGAcceleration  (vTranslationAbsolute  , en_vGravityDir  , fGA  , fGV );
}
else {
FLOAT3D vPolygonDir  = - en_vReferencePlane ;
FLOAT3D vGParallel  , vGNormal ;
GetParallelAndNormalComponents  (en_vGravityDir  , vPolygonDir  , vGNormal  , vGParallel );
FLOAT fFactor  = vGParallel  . Length  ();
if(fFactor  > 0.001f){
FLOAT fGV  = en_fGravityV  * fTickQuantum  * fSpeedModifier ;
FLOAT fGA  = (en_fGravityA  * fBouyancy ) * fTickQuantum  * fTickQuantum ;
AddGAcceleration  (vTranslationAbsolute  , vGParallel  / fFactor  , fGA  * fFactor  , fGV  * fFactor );
}
FLOAT fPolyGA  = (vPolygonDir  % en_vGravityDir ) * en_fGravityA ;
FLOAT fYSpeed  = vPolygonDir  % vTranslationAbsolute ;
if(fYSpeed  > 0 && fYSpeed  < fPolyGA ){
vTranslationAbsolute  -= vPolygonDir  * fYSpeed ;
}
if((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_BOUNCE ){
en_aDesiredRotationRelative  *= en_fJumpControlMultiplier ;
if(en_aDesiredRotationRelative  . Length  () < 10){
en_aDesiredRotationRelative  = ANGLE3D (0 , 0 , 0);
}
}
}
CSurfaceType  & stReference  = en_pwoWorld  -> wo_astSurfaceTypes  [ en_iReferenceSurface  ];
if(en_penReference  != NULL ){
FLOAT fPlaneY  = (en_vGravityDir  % en_vReferencePlane );
FLOAT fPlaneYAbs  = Abs  (fPlaneY );
FLOAT fFriction  = stReference  . st_fFriction ;
if(fPlaneY  >= - stReference  . st_fClimbSlopeCos  && fPlaneY  < 0 
|| (stReference  . st_ulFlags  & STF_SLIDEDOWNSLOPE ) && fPlaneY  > - 0.99f){
{
if(GetFlags  () & ENF_ALIVE  && ! IsEnemy  ())
{
en_ulPhysicsFlags  |= EPF_ONSTEEPSLOPE ;
AddAccelerationOnPlane2  (
vTranslationAbsolute  , 
vDesiredTranslationAbsolute  , 
ACC  * fPlaneYAbs  * fPlaneYAbs  * fFriction  * fControlMultiplier  , 
DEC  * fPlaneYAbs  * fPlaneYAbs  * fFriction  * fControlMultiplier  , 
en_vReferencePlane  , 
en_vGravityDir );
}
else 
{
en_ulPhysicsFlags  &= ~ EPF_ONSTEEPSLOPE ;
AddAccelerationOnPlane  (
vTranslationAbsolute  , 
vDesiredTranslationAbsolute  , 
ACC  * fPlaneYAbs  * fPlaneYAbs  * fFriction  * fControlMultiplier  , 
DEC  * fPlaneYAbs  * fPlaneYAbs  * fFriction  * fControlMultiplier  , 
en_vReferencePlane );
}
}
}
else 
{
FLOAT3D vPreTranslationAbs  = vTranslationAbsolute ;
en_plLastPlacementTmp  = en_plLastPlacement ;
en_penLastValidReferenceTmp  = en_penReference ;
m_bForceStop  = FALSE ;
en_ulPhysicsFlags  &= ~ EPF_ONSTEEPSLOPE ;
AddAccelerationOnPlane  (
vTranslationAbsolute  , 
vDesiredTranslationAbsolute  , 
ACC  * fPlaneYAbs  * fPlaneYAbs  * fFriction  * fControlMultiplier  , 
DEC  * fPlaneYAbs  * fPlaneYAbs  * fFriction  * fControlMultiplier  , 
en_vReferencePlane );
if(m_bFallDownToFloor )
{
vTranslationAbsolute  (1) = 0.0f;
vTranslationAbsolute  (2) = vPreTranslationAbs  (2);
vTranslationAbsolute  (3) = 0.0f;
}
}
if(fJump  < - 0.01f && (fPlaneY  < - stReference  . st_fJumpSlopeCos  
|| en_tmEntityTime  > en_tmLastSignificantVerticalMovement  + 0.25f)){
vTranslationAbsolute  += en_vGravityDir  * fJump ;
en_tmJumped  = en_tmEntityTime ;
en_pbpoStandOn  = NULL ;
}
}
else {
m_bForceStop  = FALSE ;
if(en_tmEntityTime  - en_tmJumped  < en_tmMaxJumpControl ){
AddAccelerationOnPlane  (
vTranslationAbsolute  , 
vDesiredTranslationAbsolute  , 
ACC  * fControlMultiplier  * en_fJumpControlMultiplier  , 
DEC  * fControlMultiplier  * en_fJumpControlMultiplier  , 
FLOATplane3D (en_vGravityDir  , 0));
}
if(fJump  < - 0.01f && 
en_tmEntityTime  > en_tmLastSignificantVerticalMovement  + 0.25f){
vTranslationAbsolute  += en_vGravityDir  * fJump ;
en_tmJumped  = en_tmEntityTime ;
en_pbpoStandOn  = NULL ;
}
}
}
CheckAndAddGAcceleration  (this  , vTranslationAbsolute  , fTickQuantum );
if(fFluidFriction  > 0.01f){
AddAcceleration  (vTranslationAbsolute  , FLOAT3D (0.0f , 0.0f , 0.0f) , 
0.0f , DEC  * fFluidFriction );
}
if((en_ulPhysicsFlags  & EPF_CANFADESPINNING ) && 
((ctDn  . ct_ulFlags  & CTF_FADESPINNING ) || (ctUp  . ct_ulFlags  & CTF_FADESPINNING ))){
en_aDesiredRotationRelative  *= (1 - fSpeedModifier  * 0.05f);
if(en_aDesiredRotationRelative  . Length  () < 10){
en_aDesiredRotationRelative  = ANGLE3D (0 , 0 , 0);
}
}
if(en_pbpoStandOn  == NULL  && (vTranslationAbsolute  . ManhattanNorm  () > 1E-5f || 
en_vReferencePlane  % en_vGravityDir  < 0.0f)){
en_penReference  = NULL ;
en_vReferencePlane  = FLOAT3D (0.0f , 0.0f , 0.0f);
en_iReferenceSurface  = 0;
}
en_vIntendedTranslation  = vTranslationAbsolute ;
en_mIntendedRotation  = mRotationAbsolute ;
FLOATaabbox3D box ;
en_pciCollisionInfo  -> MakeBoxAtPlacement  (FLOAT3D (0 , 0 , 0) , en_mRotation  , box );
{
CLightSource  * pls  = GetLightSource  ();
if(pls  != NULL  && ! (pls  -> ls_ulFlags  & LSF_LENSFLAREONLY )){
ASSERT  (! (pls  -> ls_ulFlags  & LSF_DIRECTIONAL ));
box  |= FLOATaabbox3D (FLOAT3D (0 , 0 , 0) , pls  -> ls_rFallOff );
}
}
box  . ExpandByFactor  (phy_fCollisionCacheAround  - 1.0f);
box  += en_plPlacement  . pl_PositionVector ;
en_boxMovingEstimate  = box ;
box  += en_vIntendedTranslation  * phy_fCollisionCacheAhead ;
en_boxMovingEstimate  |= box ;
en_vAppliedTranslation  = FLOAT3D (0.0f , 0.0f , 0.0f);
en_mAppliedRotation  . Diagonal  (1.0f);
}
void CMovableEntity::DoMoving(void) 
{
if(en_pciCollisionInfo  == NULL  || (en_ulPhysicsFlags  & EPF_FORCEADDED )){
return ;
}
if(m_bForceStop )
{
return ;
}
FLOAT fTickQuantum  = _pTimer  -> TickQuantum ;
if(en_ulPhysicsFlags  & EPF_RT_SYNCHRONIZED ){
en_vMoveTranslation  = en_vIntendedTranslation  - en_vAppliedTranslation ;
en_mMoveRotation  = en_mIntendedRotation  * ! en_mAppliedRotation ;
InitTryToMove  ();
CMovableEntity  * penPusher  = NULL ;
if((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) == EPF_ONBLOCK_PUSH ){
penPusher  = this ;
}
TryToMove  (penPusher  , TRUE  , TRUE );
}
else {
ASSERT  ((en_ulPhysicsFlags  & EPF_ONBLOCK_MASK ) != EPF_ONBLOCK_PUSH );
if(en_penReference  == NULL ){
en_vMoveTranslation  = en_vIntendedTranslation  - en_vAppliedTranslation ;
en_mMoveRotation  = en_mIntendedRotation  * ! en_mAppliedRotation ;
InitTryToMove  ();
_ctTryToMoveCheckCounter  = 4;
BOOL bMoveSuccessfull  = TryToMove  (NULL  , TRUE  , TRUE );
if(bMoveSuccessfull ){
return ;
}
}
en_vMoveTranslation  = en_vIntendedTranslation  - en_vAppliedTranslation ;
InitTryToMove  ();
TryToMove  (NULL  , TRUE  , FALSE );
en_mMoveRotation  = en_mIntendedRotation  * ! en_mAppliedRotation ;
if(
(en_mMoveRotation  (1 , 1) > 1.0001f || en_mMoveRotation  (1 , 1) < 0.9999f) || 
(en_mMoveRotation  (1 , 2) > 0.0f || en_mMoveRotation  (1 , 2) < 0.0f) || 
(en_mMoveRotation  (1 , 3) > 0.0f || en_mMoveRotation  (1 , 3) < 0.0f) || 
(en_mMoveRotation  (2 , 1) > 0.0f || en_mMoveRotation  (2 , 1) < 0.0f) || 
(en_mMoveRotation  (2 , 2) > 1.0001f || en_mMoveRotation  (2 , 2) < 0.9999f) || 
(en_mMoveRotation  (2 , 3) > 0.0f || en_mMoveRotation  (2 , 3) < 0.0f) || 
(en_mMoveRotation  (3 , 1) > 0.0f || en_mMoveRotation  (3 , 1) < 0.0f) || 
(en_mMoveRotation  (3 , 2) > 0.0f || en_mMoveRotation  (3 , 2) < 0.0f) || 
(en_mMoveRotation  (3 , 3) > 1.0001f || en_mMoveRotation  (3 , 3) < 0.9999f))
{
CTString tStr ;
tStr  . PrintF  ("%f" , en_mMoveRotation  (3 , 3));
InitTryToMove  ();
TryToMove  (NULL  , FALSE  , TRUE );
}
}
}
void CMovableEntity::PostMoving(void) 
{
en_tmEntityTime  += _pTimer  -> TickQuantum ;
if(m_bForceStop )
{
return ;
}
if(en_pciCollisionInfo  == NULL ){
en_ulFlags  |= ENF_INRENDERING ;
return ;
}
if(en_ulPhysicsFlags  & EPF_FORCEADDED ){
en_ulPhysicsFlags  &= ~ EPF_FORCEADDED ;
return ;
}
if(en_penReference  != NULL ){
en_penLastValidReference  = en_penReference ;
}
FLOAT3D vOldTranslation  = en_vCurrentTranslationAbsolute ;
FLOAT fTickQuantum  = _pTimer  -> TickQuantum ;
en_vCurrentTranslationAbsolute  = en_vAppliedTranslation  / fTickQuantum ;
if(Abs  (en_vCurrentTranslationAbsolute  % en_vGravityDir ) > 0.1f){
en_tmLastSignificantVerticalMovement  = en_tmEntityTime ;
}
ClearNextPosition  ();
FLOAT3D vSpeedDelta  = en_vIntendedTranslation  - en_vAppliedTranslation ;
FLOAT fSpeedDelta  = vSpeedDelta  . Length  () / fTickQuantum ;
en_ulPhysicsFlags  &= ~ EPF_NOIMPACTTHISTICK ;
en_vIntendedTranslation  = vOldTranslation ;
if(en_vCurrentTranslationAbsolute  . ManhattanNorm  () < 0.001f 
&& (en_vDesiredTranslationRelative  . ManhattanNorm  () == 0 || en_fAcceleration  == 0) 
&& en_aDesiredRotationRelative  . ManhattanNorm  () == 0){
if(en_penReference  != NULL ){
if(en_penReference  -> en_ulPhysicsFlags  & EPF_MOVABLE ){
CMovableEntity  * penReference  = (CMovableEntity  *) (CEntity  *) en_penReference ;
if(! penReference  -> en_lnInMovers  . IsLinked  ()){
en_ulFlags  |= ENF_INRENDERING ;
}
}
else {
en_ulFlags  |= ENF_INRENDERING ;
}
}
else {
if(
(! (en_ulPhysicsFlags  & (EPF_TRANSLATEDBYGRAVITY  | EPF_ORIENTEDBYGRAVITY )) 
|| en_fGravityA  == 0.0f || (en_ulPhysicsFlags  & EPF_FLOATING ))){
en_ulFlags  |= ENF_INRENDERING ;
}
}
if(en_ulFlags  & ENF_INRENDERING ){
en_plLastPlacement  = en_plPlacement ;
}
}
if(en_plpLastPositions  != NULL ){
en_plpLastPositions  -> AddPosition  (en_vNextPosition );
}
}
void CMovableEntity::CacheNearPolygons(void) 
{
CClipMove  cm  (this );
cm  . CacheNearPolygons  ();
}

SLONG CMovableEntity::GetUsedMemory(void) 
{
SLONG  slUsedMemory  = sizeof  (CMovableEntity ) - sizeof  (CRationalEntity ) + CRationalEntity  :: GetUsedMemory  ();
slUsedMemory  += en_apbpoNearPolygons  . sa_Count  * sizeof  (CBrushPolygon  *);
return slUsedMemory ;
}

void CMovableEntity::ClientCacheNearPolygons() {
FLOATaabbox3D box ;
if(en_pciCollisionInfo  == NULL ){
return ;
}
en_pciCollisionInfo  -> MakeBoxAtPlacement  (FLOAT3D (0 , 0 , 0) , en_mRotation  , box );
{
CLightSource  * pls  = GetLightSource  ();
if(pls  != NULL  && ! (pls  -> ls_ulFlags  & LSF_LENSFLAREONLY )){
ASSERT  (! (pls  -> ls_ulFlags  & LSF_DIRECTIONAL ));
box  |= FLOATaabbox3D (FLOAT3D (0 , 0 , 0) , pls  -> ls_rFallOff );
}
}
extern  FLOAT phy_fCollisionCacheAround ;
box  . ExpandByFactor  (phy_fCollisionCacheAround  - 1.0f);
box  += en_plPlacement  . pl_PositionVector ;
en_boxMovingEstimate  = box ;
CClipMove  cmClipMove  (this );
cmClipMove  . cm_pwoWorld  = & (_pNetwork  -> ga_World );
cmClipMove  . cm_ulTestMask1  = ((en_ulCollisionFlags  & ECF_TESTMASK ) >> ECB_TEST ) << ECB_IS ;
cmClipMove  . cm_ulTestMask2  = ((en_ulCollisionFlags  & ECF_ISMASK ) >> ECB_IS ) << ECB_TEST ;
cmClipMove  . cm_ulPassMaskA  = ((en_ulCollisionFlags  & ECF_PASSMASK ) >> ECB_PASS ) << ECB_IS ;
cmClipMove  . cm_ulPassMaskB  = ((en_ulCollisionFlags  & ECF_ISMASK ) >> ECB_IS ) << ECB_PASS ;
cmClipMove  . CacheNearPolygons  ();
}
BOOL CMovableEntity::
Dummy(const CEntityEvent &__eeInput) {
#undef STATE_CURRENT
#define STATE_CURRENT STATE_CMovableEntity_Dummy
	ASSERTMSG(__eeInput.ee_slEvent==EVENTCODE_EVoid, "CMovableEntity::Dummy expects 'EVoid' as input!");
	const EVoid &e = (const EVoid &)__eeInput;
 ASSERT(FALSE);
 return TRUE;
}
;
