/*
 * This file is generated by Entity Class Compiler, (c) CroTeam 1997-98
 */


#include "StdH.h"
#include <Engine/Entities/InternalClasses.h>
#include <Engine/Base/CRC.h>
#include <Engine/Base/Stream.h>
#include <Engine/Base/Console.h>
#include <Engine/Models/ModelObject.h>
#include <Engine/Ska/ModelInstance.h>

#include <Classes/MovableModelEntity.h>
#include <Classes/MovableModelEntity_tables.h>
void CMovableModelEntity::SetDefaultProperties(void) {
	en_iCollisionBox = 0;
	en_iWantedCollisionBox = 0;
	CMovableEntity::SetDefaultProperties();
}
void CMovableModelEntity::PreMoving(void) 
{
if(en_iCollisionBox  != en_iWantedCollisionBox ){
ChangeCollisionBoxIndexNow  (en_iWantedCollisionBox );
}
CMovableEntity  :: PreMoving  ();
}
void CMovableModelEntity::DoMoving(void) 
{
CMovableEntity  :: DoMoving  ();
}
INDEX CMovableModelEntity::GetCollisionBoxIndex(void) 
{
return en_iCollisionBox ;
}
BOOL CMovableModelEntity::CheckForCollisionNow(INDEX iNewCollisionBox,CEntity * * ppenObstacle) 
{
extern  BOOL CanEntityChangeCollisionBox  (CEntity  * pen  , INDEX iNewCollisionBox  , CEntity  * * ppenObstacle );
return ! CanEntityChangeCollisionBox  (this  , en_iCollisionBox  , ppenObstacle );
}
BOOL CMovableModelEntity::ChangeCollisionBoxIndexNow(INDEX iNewCollisionBox,CEntity * * ppenObstacle) 
{
if(iNewCollisionBox  == en_iCollisionBox ){
return TRUE ;
}
extern  BOOL CanEntityChangeCollisionBox  (CEntity  * pen  , INDEX iNewCollisionBox  , CEntity  * * ppenObstacle );
BOOL bCanChange  = CanEntityChangeCollisionBox  (this  , iNewCollisionBox  , ppenObstacle );
if(! bCanChange ){
return FALSE ;
}
if(en_RenderType  == CEntity  :: RT_SKAMODEL  || en_RenderType  == CEntity  :: RT_SKAEDITORMODEL ){
if(GetModelInstance  () != NULL ){
GetModelInstance  () -> SetCurrentColisionBoxIndex  (iNewCollisionBox );
}
}
en_iCollisionBox  = iNewCollisionBox ;
en_iWantedCollisionBox  = iNewCollisionBox ;
ModelChangeNotify  ();
return TRUE ;
}
BOOL CMovableModelEntity::ChangeCollisionBoxIndexNow(INDEX iNewCollisionBox) 
{
CEntity  * penDummy ;
return ChangeCollisionBoxIndexNow  (iNewCollisionBox  , & penDummy );
}
void CMovableModelEntity::ForceCollisionBoxIndexChange(INDEX iNewCollisionBox) 
{
if(en_RenderType  == CEntity  :: RT_SKAMODEL  || en_RenderType  == CEntity  :: RT_SKAEDITORMODEL ){
if(GetModelInstance  () != NULL ){
GetModelInstance  () -> SetCurrentColisionBoxIndex  (iNewCollisionBox );
}
}
en_iCollisionBox  = iNewCollisionBox ;
en_iWantedCollisionBox  = iNewCollisionBox ;
ModelChangeNotify  ();
}
void CMovableModelEntity::ChangeCollisionBoxIndexWhenPossible(INDEX iNewCollisionBox) 
{
en_iWantedCollisionBox  = iNewCollisionBox ;
}
void CMovableModelEntity::Read_t(CTStream * istr,BOOL bNetwork) 
{
CMovableEntity  :: Read_t  (istr  , bNetwork );
}
void CMovableModelEntity::Write_t(CTStream * ostr,BOOL bNetwork) 
{
CMovableEntity  :: Write_t  (ostr  , bNetwork );
}

SLONG CMovableModelEntity::GetUsedMemory(void) 
{
return (sizeof  (CMovableModelEntity ) - sizeof  (CMovableEntity ) + CMovableEntity  :: GetUsedMemory  ());
}
void CMovableModelEntity::DeathNow() {
}
BOOL CMovableModelEntity::
Dummy(const CEntityEvent &__eeInput) {
#undef STATE_CURRENT
#define STATE_CURRENT STATE_CMovableModelEntity_Dummy
	ASSERTMSG(__eeInput.ee_slEvent==EVENTCODE_EVoid, "CMovableModelEntity::Dummy expects 'EVoid' as input!");
	const EVoid &e = (const EVoid &)__eeInput;
 ASSERT(FALSE);
 return TRUE;
}
;
BOOL CMovableModelEntity::
WaitUntilScheduledAnimStarts(const CEntityEvent &__eeInput) {
#undef STATE_CURRENT
#define STATE_CURRENT STATE_CMovableModelEntity_WaitUntilScheduledAnimStarts
	ASSERTMSG(__eeInput.ee_slEvent==EVENTCODE_EVoid, "CMovableModelEntity::WaitUntilScheduledAnimStarts expects 'EVoid' as input!");
	const EVoid &e = (const EVoid &)__eeInput;
ASSERT  (en_RenderType  == CEntity  :: RT_MODEL  || en_RenderType  == CEntity  :: RT_EDITORMODEL );
FLOAT fToWait  = GetModelObject  () -> ao_tmAnimStart  - _pTimer  -> CurrentTick  ();
if(!(fToWait  > 0)){
 Jump(STATE_CURRENT,0x00020004, FALSE, EInternal());
return TRUE;
}
SetTimerAfter(fToWait  + _pTimer  -> TickQuantum );
Jump(STATE_CURRENT, 0x00020002, FALSE, EBegin());
return TRUE;
}
BOOL CMovableModelEntity::H0x00020002_WaitUntilScheduledAnimStarts_01(const CEntityEvent &__eeInput) {
#undef STATE_CURRENT
#define STATE_CURRENT 0x00020002
switch(__eeInput.ee_slEvent) {
case EVENTCODE_EBegin: return TRUE;
case EVENTCODE_ETimer: Jump(STATE_CURRENT,0x00020003, FALSE, EInternal());
 return TRUE;
default: return FALSE;
 }
}
BOOL CMovableModelEntity::H0x00020003_WaitUntilScheduledAnimStarts_02(const CEntityEvent &__eeInput){
ASSERT(__eeInput.ee_slEvent==EVENTCODE_EInternal);
#undef STATE_CURRENT
#define STATE_CURRENT 0x00020003
;
Jump(STATE_CURRENT,0x00020004, FALSE, EInternal());
return TRUE;
}
BOOL CMovableModelEntity::H0x00020004_WaitUntilScheduledAnimStarts_03(const CEntityEvent &__eeInput){
ASSERT(__eeInput.ee_slEvent==EVENTCODE_EInternal);
#undef STATE_CURRENT
#define STATE_CURRENT 0x00020004

Return(STATE_CURRENT,EReturn  ());
return TRUE;
 ASSERT(FALSE);
 return TRUE;
}
;
