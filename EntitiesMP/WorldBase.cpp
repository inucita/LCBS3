/*
 * This file is generated by Entity Class Compiler, (c) CroTeam 1997-98
 */

#line 2 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"

#include "StdH.h"
#include "EntitiesMP/BackgroundViewer.h"
#include "EntitiesMP/WorldSettingsController.h"
// for error checking:
#include "EntitiesMP/SoundHolder.h"
#include "EntitiesMP/PlayerMarker.h"
//#include "EntitiesMP/KeyItem.h"
#include "EntitiesMP/DoorController.h"
#include "EntitiesMP/Counter.h"
#include "EntitiesMP/ModelHolder.h"
#include "EntitiesMP/MusicHolder.h"
#include "EntitiesMP\GravityMarker.h"
#include "EntitiesMP\GravityRouter.h"

#include <EntitiesMP/WorldBase.h>
#include <EntitiesMP/WorldBase_tables.h>
#line 23 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"


//안태훈 수정 시작	//(Modify Worldbase Overbright to NonOver)(0.1)
extern COLOR g_colNewGameShadeColor = C_WHITE | CT_OPAQUE;
//안태훈 수정 끝	//(Modify Worldbase Overbright to NonOver)(0.1)


inline void Clear(EntityStats &es) {es.es_strName.Clear();};
static CDynamicArray<EntityStats> _aes;
static CAnimObject _aoLightningColor;

EntityStats *FindStats(const CTString &strName)
{
	{FOREACHINDYNAMICARRAY(_aes, EntityStats, ites) {
		EntityStats &es = *ites;
		if (es.es_strName==strName) {
			return &es;
		}
	}}
	return NULL;
}

static void MakeWorldStatistics(void)
{
	// get the world pointer
	CWorld *pwo = (CWorld *)_pShell->GetINDEX("pwoCurrentWorld");
	// if there is no current world
	if (pwo==NULL) {
		CPrintF("No current world.\n");
		return;
	}

	// for each entity in the world
	{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, iten) {
		// get its stats
		EntityStats esCurrent;
		BOOL bHasStats = iten->FillEntityStatistics(&esCurrent);
		// if no stats
		if (!bHasStats) {
			// skip it
			continue;
		}

		// find existing stats with same name
		EntityStats *pesOld = FindStats(esCurrent.es_strName);
		// if such stats exists
		if (pesOld!=NULL) {
			// update the existing stats
			pesOld->es_ctCount    += esCurrent.es_ctCount;
			pesOld->es_ctAmmount  += esCurrent.es_ctAmmount*esCurrent.es_ctCount;
			pesOld->es_fValue     += esCurrent.es_fValue*esCurrent.es_ctCount;
//			pesOld->es_iScore     += esCurrent.es_iScore*esCurrent.es_ctCount;
		// if this a new name
		} else {
			// create new stats
			EntityStats &esNew = *_aes.New();
			esNew.es_strName    = esCurrent.es_strName;
			esNew.es_ctCount    = esCurrent.es_ctCount;
			esNew.es_ctAmmount  = esCurrent.es_ctAmmount*esCurrent.es_ctCount;
			esNew.es_fValue     = esCurrent.es_fValue*esCurrent.es_ctCount;
//			esNew.es_iScore     = esCurrent.es_iScore*esCurrent.es_ctCount;
		}
	}}

	// dump all stats
	try {
		CTFileStream strm;
		CTFileName fnm = CTString("Temp\\Statistics.txt");
		strm.Create_t(fnm);
		CTString strLine;
		strLine.PrintF("%-40s: %8s %8s %10s %10s", 
			"name", "count", "ammount", "health", "score");
		strm.PutLine_t(strLine);
		{FOREACHINDYNAMICARRAY(_aes, EntityStats, ites) {
			EntityStats &es = *ites;
			CTString strLine;
			strLine.PrintF("%-40s: %8d %8d %10g", 
				es.es_strName, es.es_ctCount, es.es_ctAmmount, es.es_fValue);
			strm.PutLine_t(strLine);
		}}
		CPrintF("Dumped to '%s'\n", CTString(fnm));
	} catch (char *strError) {
		CPrintF("Error: %s\n", strError);
	}

	_aes.Clear();
}

static void ReoptimizeAllBrushes(void)
{
	// get the world pointer
	CWorld *pwo = (CWorld *)_pShell->GetINDEX("pwoCurrentWorld");
	// if there is no current world
	if (pwo==NULL) {
		CPrintF("No current world.\n");
		return;
	}

	// for each brush in the world
	FOREACHINDYNAMICARRAY(pwo->wo_baBrushes.ba_abrBrushes, CBrush3D, itbr) {
		CBrush3D &br=*itbr;
		// for each mip in the brush
		FOREACHINLIST(CBrushMip, bm_lnInBrush, itbr->br_lhBrushMips, itbm) {
			// reoptimize it
			itbm->Reoptimize();
		}
	}
	CPrintF("All brushes reoptimized.\n");
}

static void DoLevelSafetyChecks()
{
	
	BOOL bWorldSettingsControllerExists = FALSE;
	
	CPrintF("\n****  BEGIN Level safety checking  ****\n\n");
	
	// get the world pointer
	CWorld *pwo = (CWorld *)_pShell->GetINDEX("pwoCurrentWorld");
	// if there is no current world
	if (pwo==NULL) {
		CPrintF("Error - no current world.\n");
		return;
	}
	
	CPrintF("STEP 1 - Checking model holders...\n");
	// for model holder in the world;
	{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, iten) {  
		if( IsOfClass( iten, &CModelHolder_DLLClass)) {
			CModelHolder2 *mh = (CModelHolder2*)&*iten;
			FLOAT3D vPos = mh->GetPlacement().pl_PositionVector;
			if (mh->m_penDestruction == NULL) {
				CPrintF("  ModelHolder2 '%s' at (%2.2f, %2.2f, %2.2f) has no destruction\n", mh->m_strName, vPos(1), vPos(2), vPos(3));
			}
		}
		if( IsOfClass( iten, &CModelHolder3_DLLClass)) {
			CModelHolder3 *mh = (CModelHolder3*)&*iten;
			FLOAT3D vPos = mh->GetPlacement().pl_PositionVector;
			if (mh->m_penDestruction == NULL) {
				CPrintF("  ModelHolder3 '%s' at (%2.2f, %2.2f, %2.2f) has no destruction\n", mh->m_strName, vPos(1), vPos(2), vPos(3));
			}
		}
	}}

	CPrintF("STEP 2 - Checking sound holders...\n");
	// for each sound holder in the world
	{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, iten) {
		if( IsOfClass( iten, &CSoundHolder_DLLClass)) {
			CSoundHolder *sh = (CSoundHolder *)&*iten;
			FLOAT3D vPos = sh->GetPlacement().pl_PositionVector;
			if (sh->m_fnSound == CTFILENAME("Data\\Sounds\\Default.wav")) {
				CPrintF("  sound holder '%s' at (%2.2f, %2.2f, %2.2f) has default sound!\n", sh->m_strName, vPos(1), vPos(2), vPos(3));
			}
		}
	}}
	

	CPrintF("STEP 3 - Checking other important entities...\n");
	CWorldSettingsController *pwsc = NULL;
	class CBackgroundViewer *penBcgViewer = (CBackgroundViewer *) pwo->GetBackgroundViewer();
	if( penBcgViewer != NULL) {
		// obtain world settings controller 
		pwsc = (CWorldSettingsController *) &*penBcgViewer->m_penWorldSettingsController;
	}
	
	if (pwsc!=NULL) {
		CPrintF("  OK! World settings controller exists!\n");
	} else {
		CPrintF("  ERROR! World settings controller does not exist (or isn't connected to the background viewer)!\n");
	}

	CPrintF("STEP 4 - Enumerating music holders...\n");
	// for each music holder in the world
	INDEX ctMusicHolders = 0;
	{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, iten) {
		if( IsOfClass( iten, &CMusicHolder_DLLClass)) {
			ctMusicHolders++;      
		}
	}}
	if (ctMusicHolders==0) {
		CPrintF("  ERROR! No music holder found in the world!\n");
	} else if (ctMusicHolders>1) {
		CPrintF("  ERROR! %d music holders (only one is allowed!) found in the world!\n", ctMusicHolders);
	} else {
		CPrintF("  OK! One music holder exists in the world!\n");
	}

	CPrintF("\n****  END Level safety checking  ****\n");

}



static void ConversionCheckForMH2(const CTString &fnmSourceModel, INDEX iType)
{
	// get the world pointer
	CWorld *pwo = (CWorld *)_pShell->GetINDEX("pwoCurrentWorld");
	// if there is no current world
	if (pwo==NULL) {
		CPrintF("Error - no current world.\n");
		return;
	}
	CPrintF("Searching for all models '%s'!\n", fnmSourceModel);
	// for all entities in this world
	{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, itenMH2) {
		if( IsOfClass( itenMH2, &CModelHolder2_DLLClass)) {
			CModelHolder2 *penMH2 = (CModelHolder2 *)&*itenMH2;
			INDEX iEntityID = penMH2->en_ulID;
			if (penMH2->m_fnModel==fnmSourceModel) {
				// copy all properties
				FLOAT3D vPos = penMH2->GetPlacement().pl_PositionVector;
				CPrintF("<ID:%d> found matching model at <%2.2f, %2.2f, %2.2f>\n",
								 iEntityID, vPos(1), vPos(2), vPos(3));
				
				// inspect all pointer values of all entities in the world that point to old model
				{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, itenOther){
					// get the DLL class of this entity
					CDLLEntityClass *pdecDLLClass = itenOther->en_pecClass->ec_pdecDLLClass;
					
					// for all classes in hierarchy of this entity
					for(;
					pdecDLLClass!=NULL;
					pdecDLLClass = pdecDLLClass->dec_pdecBase) {
						// for all properties
						for(INDEX iProperty=0; iProperty<pdecDLLClass->dec_ctProperties; iProperty++) {
							CEntityProperty &epProperty = pdecDLLClass->dec_aepProperties[iProperty];              
							// if the property type is entity pointer
							if (epProperty.ep_eptType == CEntityProperty::EPT_ENTITYPTR) {
								// get the pointer
								CEntityPointer &penPointed = ENTITYPROPERTY(&*itenOther, epProperty.ep_slOffset, CEntityPointer);
								// if it points to the entity to be untargeted
								if (penPointed == penMH2) {
									// if entity is AnimationChanger
									if( IsOfClass( itenOther, &CAnimationChanger_DLLClass)) {
										CPrintF("<ID:%d> WARNING! Animation Changer '%s' (ID:%d) points to inspected model\n",
											iEntityID, itenOther->GetName(), itenOther->en_ulID);
									} else if (iType>0) {
										CPrintF("<ID:%d> Entity '%s' (ID:%d) points to inspected model\n", 
											iEntityID, itenOther->GetName(), itenOther->en_ulID);
									}
								}
							}
						}
					}
				}}//FOREACHINDYNAMICCONTAINER
				
			}
		}
	}}//FOREACHINDYNAMICCONTAINER
}


static void ConvertSingleMH2ToMH3(const CTString &fnmSourceModel)
{
	// get the world pointer
	CWorld *pwo = (CWorld *)_pShell->GetINDEX("pwoCurrentWorld");
	// if there is no current world
	if (pwo==NULL) {
		CPrintF("Error - no current world.\n");
		return;
	}
	// create the ModelHolder3 entity just to test if it works
	CEntity *penNewClass = NULL;
	CPlacement3D pl = CPlacement3D(FLOAT3D(0.0f, 0.0f, 0.0f),
																 ANGLE3D(0.0f, 0.0f, 0.0f));
	
	_pShell->Execute("WED_DeselectAll();");
	
	CPrintF("\nSearching for all '%s' models!\n----------\n", fnmSourceModel);
	// for all entities in this world
	{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, itenMH2) {
		if( IsOfClass( itenMH2, &CModelHolder2_DLLClass)) {
			CModelHolder2 *penMH2 = (CModelHolder2 *)&*itenMH2;
			INDEX iEntityID = penMH2->en_ulID;
			if (penMH2->m_fnModel==fnmSourceModel) {
				CTFileName fnmTargetModel = CTFileName(fnmSourceModel).NoExt() + CTString(".smc");      
				if (FileExists(fnmTargetModel)) {
					FLOAT3D vPos = penMH2->GetPlacement().pl_PositionVector;
					CPrintF("<ID:%d> at <%2.2f, %2.2f, %2.2f> to '%s'\n",
						iEntityID, vPos(1), vPos(2), vPos(3), fnmTargetModel);
					CEntity *penNewClass;
					// create new ModelHolder3
					try {
						CModelInstance *pmi = NULL;
						pmi = ObtainModelInstance_t(fnmTargetModel);
						DeleteModelInstance(pmi);
						penNewClass = pwo->CreateEntity_t(pl, CTFILENAME("Classes\\ModelHolder3.ecl"));
					} catch(char *strError) {
						WarningMessage("<%s>:\n%s", (CTString &)fnmTargetModel, strError);            
						CPrintF("<ID:%d> FAILED!\n----------\n", iEntityID); 
						CPrintF("ABORTING further attempts!....\n"); 
						break;
					}
					// copy all properties
					CModelHolder2 *penOld = penMH2;
					CModelHolder3 *penNew = (CModelHolder3 *)penNewClass;
					penNew->m_fnModel = fnmTargetModel;
					penNew->m_fStretchAll = penOld->m_fStretchAll;
					penNew->m_vStretchXYZ(1) = penOld->m_fStretchX;
					penNew->m_vStretchXYZ(2) = penOld->m_fStretchY;
					penNew->m_vStretchXYZ(3) = penOld->m_fStretchZ;
					penNew->m_strName = penOld->m_strName;
					penNew->m_strDescription = penOld->m_strDescription;
					penNew->m_bColliding = penOld->m_bColliding;
					penNew->m_strModelAnimation = "";
					penNew->m_stClusterShadows = penOld->m_stClusterShadows;
					penNew->m_bBackground = penOld->m_bBackground;
					penNew->m_bTargetable = penOld->m_bTargetable;
					penNew->m_cstCustomShading = penOld->m_cstCustomShading;
					penNew->m_aShadingDirection = penOld->m_aShadingDirection;
					penNew->m_colLight   = penOld->m_colLight  ;
					penNew->m_colAmbient = penOld->m_colAmbient;
					penNew->m_bActive = penOld->m_bActive;
					penNew->m_rMipFadeDistMetric = MipFactor_LogToMetric(penOld->m_fMipFadeDist);
					penNew->m_fMipFadeLenMetric  = MipFactor_LogToMetric(penOld->m_fMipFadeLen + penOld->m_fMipFadeDist) 
																															 - penNew->m_rMipFadeDistMetric;
					penNew->m_bRandomStretch = FALSE;
					penNew->m_fStretchRndXYZ(1) = penOld->m_fStretchRndX;
					penNew->m_fStretchRndXYZ(2) = penOld->m_fStretchRndY;
					penNew->m_fStretchRndXYZ(3) = penOld->m_fStretchRndZ;
					penNew->m_fStretchRndAll = penOld->m_fStretchRndAll; 
					penNew->m_fStretchRandom = penOld->m_fStretchRandom; 
					penNew->m_penDestruction = penOld->m_penDestruction;
					penNew->m_vDamage = penOld->m_vDamage;
					penNew->m_tmLastDamage = penOld->m_tmLastDamage;
					penNew->m_penDestroyTarget = penOld->m_penDestroyTarget;
					penNew->m_penLastDamager   = penOld->m_penLastDamager;
					penNew->m_tmSpraySpawned    = penOld->m_tmSpraySpawned;
					penNew->m_fSprayDamage      = penOld->m_fSprayDamage;  
					penNew->m_penSpray          = penOld->m_penSpray;    
					penNew->m_fMaxDamageAmmount = penOld->m_fMaxDamageAmmount;
					penNew->m_fClassificationStretch = penOld->m_fClassificationStretch;
					penNew->m_colBurning             = penOld->m_colBurning           ; 
					penNew->m_dmtLastDamageType      = penOld->m_dmtLastDamageType    ; 
					penNew->m_fChainSawCutDamage     = penOld->m_fChainSawCutDamage   ; 
					penNew->m_fMaxTessellationLevel  = penOld->m_fMaxTessellationLevel; 
					penNew->SetParent(penOld->GetParent());
					penNew->SetSpawnFlags(penOld->GetSpawnFlags());
					penNew->SetFlags(penOld->GetFlags());
					penNewClass->Initialize();
					// now teleport the new to the new position (needed before setting of the parents)
					penNew->Teleport(penOld->GetPlacement(), FALSE);
					// remap all pointer values of all entities in the world that point to old model
					{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, itenOther){
						// get the DLL class of this entity
						CDLLEntityClass *pdecDLLClass = itenOther->en_pecClass->ec_pdecDLLClass;
						// if its parent is the entity, change it to new
						if (itenOther->GetParent()==penOld) {
							itenOther->SetParent(penNew);
						}
						// for all classes in hierarchy of this entity
						for(;
						pdecDLLClass!=NULL;
						pdecDLLClass = pdecDLLClass->dec_pdecBase) {
							// for all properties
							for(INDEX iProperty=0; iProperty<pdecDLLClass->dec_ctProperties; iProperty++) {
								CEntityProperty &epProperty = pdecDLLClass->dec_aepProperties[iProperty];                              
								// if the property type is entity pointer
								if (epProperty.ep_eptType == CEntityProperty::EPT_ENTITYPTR) {
									// get the pointer
									CEntityPointer &penPointed = ENTITYPROPERTY(&*itenOther, epProperty.ep_slOffset, CEntityPointer);
									// if it points to the entity to be untargeted
									if (penPointed == penOld) {
										// if entity is AnimationChanger
										if( IsOfClass( itenOther, &CAnimationChanger_DLLClass)) {
											CPrintF("<ID:%d> WARNING! Animation Changer pointing to <%d> is no longer valid!\n", iEntityID, iEntityID);
										}
										penPointed = penNew;                  
									}                  
								}
							}
						}
					}} // end remapping
					// delete the old model
					penOld->Destroy();
					CPrintF("<ID:%d> SUCCESS! new -> (ID:%d)\n----------\n", iEntityID, penNew->en_ulID);          
				}
			}
		}
	}}

/*for (each ModelHolder2 in world = SOURCE)
	{
		// 1st pass
		make ModelHolder3 name = MH3NAME
		if (exists MH3NAME) {
			try creating a mh3 entity = MODEL3
			if (can't) <FAIL>
		} else {
			continue;
		}
		// 2nd pass - convert properties
		copy all possible properties from SOURCE to MODEL3
		// 3rd pass - remap entity pointers from old to new model
		for (ALL entities in world = ENTITY)
		{
			if (ENTITY has a pointer property that points to SOURCE)
			{
				if (ENTITY is AnimationChanger)
				{
					inform user that animations are not valid any more        
				}
				remap pointer to new
			}
		}
	}*/
}

static void ConvertAllMH2ToMH3( void )
{
	// get the world pointer
	CWorld *pwo = (CWorld *)_pShell->GetINDEX("pwoCurrentWorld");
	// if there is no current world
	if (pwo==NULL) {
		CPrintF("Error - no current world.\n");
		return;
	}
	// create the ModelHolder3 entity just to test if it works
	CEntity *penNewClass = NULL;
	CPlacement3D pl = CPlacement3D(FLOAT3D(0.0f, 0.0f, 0.0f),
																 ANGLE3D(0.0f, 0.0f, 0.0f));
	
	_pShell->Execute("WED_DeselectAll();");
	
	CPrintF("\nSearching for ModelHolder2 entities\n----------\n");
	// for all entities in this world
	{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, itenMH2) {
		if( IsOfClass( itenMH2, &CModelHolder2_DLLClass)) {
			CModelHolder2 *penMH2 = (CModelHolder2*)&*itenMH2;
			INDEX iEntityID = penMH2->en_ulID;
			CTFileName fnmSourceModel = penMH2->m_fnModel;
			CTFileName fnmTargetModel = CTFileName(fnmSourceModel).NoExt() + CTString(".smc");      
			if (FileExists(fnmTargetModel)) {
				FLOAT3D vPos = penMH2->GetPlacement().pl_PositionVector;
				CPrintF("<ID:%d> at <%2.2f, %2.2f, %2.2f>...\n", iEntityID, vPos(1), vPos(2), vPos(3));
				CPrintF("<ID:%d> ...possible substitution '%s'\n", iEntityID, fnmTargetModel);
				CEntity *penNewClass;
				// create new ModelHolder3
				try {
					CModelInstance *pmi = NULL;
					pmi = ObtainModelInstance_t(fnmTargetModel);
					DeleteModelInstance(pmi);
					penNewClass = pwo->CreateEntity_t(pl, CTFILENAME("Classes\\ModelHolder3.ecl"));
				} catch(char *strError) {
					WarningMessage("<%s>:\n%s", (CTString &)fnmTargetModel, strError);            
					CPrintF("<ID:%d> FAILED!\n----------\n", iEntityID); 
					continue;
				}
				// copy all properties
				CModelHolder2 *penOld = penMH2;
				CModelHolder3 *penNew = (CModelHolder3 *)penNewClass;
				penNew->m_fnModel = fnmTargetModel;
				penNew->m_fStretchAll = penOld->m_fStretchAll;
				penNew->m_vStretchXYZ(1) = penOld->m_fStretchX;
				penNew->m_vStretchXYZ(2) = penOld->m_fStretchY;
				penNew->m_vStretchXYZ(3) = penOld->m_fStretchZ;
				penNew->m_strName = penOld->m_strName;
				penNew->m_strDescription = penOld->m_strDescription;
				penNew->m_bColliding = penOld->m_bColliding;
				penNew->m_strModelAnimation = "";
				penNew->m_stClusterShadows = penOld->m_stClusterShadows;
				penNew->m_bBackground = penOld->m_bBackground;
				penNew->m_bTargetable = penOld->m_bTargetable;
				penNew->m_cstCustomShading = penOld->m_cstCustomShading;
				penNew->m_aShadingDirection = penOld->m_aShadingDirection;
				penNew->m_colLight   = penOld->m_colLight  ;
				penNew->m_colAmbient = penOld->m_colAmbient;
				penNew->m_bActive = penOld->m_bActive;
				penNew->m_rMipFadeDistMetric = MipFactor_LogToMetric(penOld->m_fMipFadeDist);
				penNew->m_fMipFadeLenMetric  = MipFactor_LogToMetric(penOld->m_fMipFadeLen + penOld->m_fMipFadeDist) 
					- penNew->m_rMipFadeDistMetric;
				penNew->m_bRandomStretch = FALSE;
				penNew->m_fStretchRndXYZ(1) = penOld->m_fStretchRndX;
				penNew->m_fStretchRndXYZ(2) = penOld->m_fStretchRndY;
				penNew->m_fStretchRndXYZ(3) = penOld->m_fStretchRndZ;
				penNew->m_fStretchRndAll = penOld->m_fStretchRndAll; 
				penNew->m_fStretchRandom = penOld->m_fStretchRandom; 
				penNew->m_penDestruction = penOld->m_penDestruction;
				penNew->m_vDamage = penOld->m_vDamage;
				penNew->m_tmLastDamage = penOld->m_tmLastDamage;
				penNew->m_penDestroyTarget = penOld->m_penDestroyTarget;
				penNew->m_penLastDamager   = penOld->m_penLastDamager;
				penNew->m_tmSpraySpawned    = penOld->m_tmSpraySpawned;
				penNew->m_fSprayDamage      = penOld->m_fSprayDamage;  
				penNew->m_penSpray          = penOld->m_penSpray;    
				penNew->m_fMaxDamageAmmount = penOld->m_fMaxDamageAmmount;
				penNew->m_fClassificationStretch = penOld->m_fClassificationStretch;
				penNew->m_colBurning             = penOld->m_colBurning           ; 
				penNew->m_dmtLastDamageType      = penOld->m_dmtLastDamageType    ; 
				penNew->m_fChainSawCutDamage     = penOld->m_fChainSawCutDamage   ; 
				penNew->m_fMaxTessellationLevel  = penOld->m_fMaxTessellationLevel; 
				penNew->SetParent(penOld->GetParent());
				penNew->SetSpawnFlags(penOld->GetSpawnFlags());
				penNew->SetFlags(penOld->GetFlags());
				penNewClass->Initialize();
				// now teleport the new to the new position (needed before setting of the parents)
				penNew->Teleport(penOld->GetPlacement(), FALSE);
				// remap all pointer values of all entities in the world that point to old model
				{FOREACHINDYNAMICCONTAINER(pwo->wo_cenEntities, CEntity, itenOther){
					// get the DLL class of this entity
					CDLLEntityClass *pdecDLLClass = itenOther->en_pecClass->ec_pdecDLLClass;
					// if its parent is the entity, change it to new
					if (itenOther->GetParent()==penOld) {
						itenOther->SetParent(penNew);
					}
					// for all classes in hierarchy of this entity
					for(;
					pdecDLLClass!=NULL;
					pdecDLLClass = pdecDLLClass->dec_pdecBase) {
						// for all properties
						for(INDEX iProperty=0; iProperty<pdecDLLClass->dec_ctProperties; iProperty++) {
							CEntityProperty &epProperty = pdecDLLClass->dec_aepProperties[iProperty];                            
							// if the property type is entity pointer
							if (epProperty.ep_eptType == CEntityProperty::EPT_ENTITYPTR) {
								// get the pointer
								CEntityPointer &penPointed = ENTITYPROPERTY(&*itenOther, epProperty.ep_slOffset, CEntityPointer);
								// if it points to the entity to be untargeted
								if (penPointed == penOld) {
									// if entity is AnimationChanger
									if( IsOfClass( itenOther, &CAnimationChanger_DLLClass)) {
										CPrintF("<ID:%d> WARNING! Animation Changer pointing to <%d> is no longer valid!\n", iEntityID, iEntityID);
									}
									penPointed = penNew;                  
								}                
							}
						}
					}
				}} // end remapping        
				// delete the old model
				penOld->Destroy();
				CPrintF("<ID:%d> SUCCESS! new (ID:%d)\n----------\n", iEntityID, penNew->en_ulID);          
			}      
		}
	}}
}



void SetPyramidPlateActivateAlpha(CWorld *pwo, INDEX iBlending,
																	TIME tmActivated, TIME tmDeactivated, BOOL bPulsate)
{
	TIME tmNow = _pTimer->CurrentTick();
	TIME tmStop = 2.0f;
	FLOAT fRatio;

	// get alpha
	if( tmNow>tmDeactivated)
	{
		// if plate is deactivated
		if( tmNow>tmDeactivated+tmStop)
		{
			fRatio = 0;
		}
		// if fading out
		else
		{
			fRatio = CalculateRatio(tmNow, tmDeactivated, tmDeactivated+tmStop, 0.0f, 1.0f);
		}
	}
	else if( tmNow>tmActivated)
	{
		// if full visible
		if( tmNow>tmActivated+tmStop)
		{
			fRatio = 1;
		}
		else
		{
			// fade in
			fRatio = CalculateRatio(tmNow, tmActivated, tmActivated+tmStop, 1.0f, 0.0f);
		}
	}
	// not yet activated
	else
	{
		fRatio = 0;
	}
	FLOAT fSinFactor = 1.0f;
	if( bPulsate)
	{
		fSinFactor = Sin((tmNow-tmActivated) * 720.0f)*0.5f+0.5f;
	}
	
	UBYTE ub = UBYTE( fRatio*fSinFactor*255.0f);
	// apply blend or add
	if( pwo->wo_atbTextureBlendings[iBlending].tb_ubBlendingType == STXF_BLEND_ALPHA)
	{
		pwo->wo_atbTextureBlendings[iBlending].tb_colMultiply = C_WHITE|ub;
	}
	else if( pwo->wo_atbTextureBlendings[iBlending].tb_ubBlendingType == STXF_BLEND_ADD)
	{
		pwo->wo_atbTextureBlendings[iBlending].tb_colMultiply = RGBAToColor(ub,ub,ub,255);
	}
}

void SetPyramidMorphRoomAlpha(CWorld *pwo, INDEX iBlending, TIME tmActivated)
{
	TIME tmNow = _pTimer->CurrentTick();
	TIME tmDelta = tmNow-tmActivated;
	FLOAT fRatio;
	FLOAT tmAppear=10.0f;

	if( tmNow<=tmActivated) { return;}
	
	// get alpha
	if( tmNow>=tmActivated+tmAppear)
	{
		fRatio = 1;
	}
	else
	{
		fRatio = CalculateRatio(tmNow, tmActivated, tmActivated+tmAppear, 1.0f, 0.0f);
	}

	FLOAT fSinFactor = Sin(-90+tmDelta*90*(1.0f+tmDelta/tmAppear*4))*0.5f+0.5f;
	//FLOAT fSinFactor = Sin(-90+90*tmDelta)*0.5f+0.5f;
	//UBYTE ub = fSinFactor*255.0f;
	UBYTE ub = UBYTE((fRatio+(1.0f-fRatio)*fSinFactor)*255.0f);

	// apply blend or add
	if( pwo->wo_atbTextureBlendings[iBlending].tb_ubBlendingType == STXF_BLEND_ALPHA)
	{
		pwo->wo_atbTextureBlendings[iBlending].tb_colMultiply = C_WHITE|ub;
	}
	else if( pwo->wo_atbTextureBlendings[iBlending].tb_ubBlendingType == STXF_BLEND_ADD)
	{
		pwo->wo_atbTextureBlendings[iBlending].tb_colMultiply = RGBAToColor(ub,ub,ub,255);
	}
}
		
void CWorldBase_OnWorldInit(CWorld *pwo)
{
	pwo->wo_attTextureTransformations[0].tt_strName = "None";
	pwo->wo_attTextureTransformations[1].tt_strName = "R Extremly Slow";
	pwo->wo_attTextureTransformations[2].tt_strName = "R Very Slow";
	pwo->wo_attTextureTransformations[3].tt_strName = "R Slow";
	pwo->wo_attTextureTransformations[4].tt_strName = "R Medium";
	pwo->wo_attTextureTransformations[5].tt_strName = "R Fast";
	pwo->wo_attTextureTransformations[6].tt_strName = "R Very Fast";
	pwo->wo_attTextureTransformations[7].tt_strName = "R Extremly Fast";

	pwo->wo_attTextureTransformations[8].tt_strName = "Dummy 1";
	pwo->wo_attTextureTransformations[9].tt_strName = "Dummy 2";
	pwo->wo_attTextureTransformations[10].tt_strName = "Dummy 3";

	pwo->wo_attTextureTransformations[11].tt_strName = "Water movement extremly slow";
	pwo->wo_attTextureTransformations[12].tt_strName = "Water movement very slow";
	pwo->wo_attTextureTransformations[13].tt_strName = "Water movement slow";
	pwo->wo_attTextureTransformations[14].tt_strName = "Water movement normal";
	pwo->wo_attTextureTransformations[15].tt_strName = "Water movement fast";
	
	pwo->wo_attTextureTransformations[16].tt_strName = "Stormy sky appearing";

	pwo->wo_attTextureTransformations[17].tt_strName = "Rotation Left 1";
	pwo->wo_attTextureTransformations[18].tt_strName = "Rotation Left 2";
	pwo->wo_attTextureTransformations[19].tt_strName = "Rotation Left 3";
	pwo->wo_attTextureTransformations[20].tt_strName = "Rotation Left 4";
	pwo->wo_attTextureTransformations[21].tt_strName = "Rotation Left 5";
	pwo->wo_attTextureTransformations[22].tt_strName = "Rotation Left 6";
	pwo->wo_attTextureTransformations[23].tt_strName = "Rotation Left 7";
	pwo->wo_attTextureTransformations[24].tt_strName = "Rotation Left 8";
	pwo->wo_attTextureTransformations[25].tt_strName = "Rotation Left 9";
	pwo->wo_attTextureTransformations[26].tt_strName = "Rotation Left 10";

	pwo->wo_attTextureTransformations[27].tt_strName = "Rotation Right 1";
	pwo->wo_attTextureTransformations[28].tt_strName = "Rotation Right 2";
	pwo->wo_attTextureTransformations[29].tt_strName = "Rotation Right 3";
	pwo->wo_attTextureTransformations[30].tt_strName = "Rotation Right 4";
	pwo->wo_attTextureTransformations[31].tt_strName = "Rotation Right 5";
	pwo->wo_attTextureTransformations[32].tt_strName = "Rotation Right 6";
	pwo->wo_attTextureTransformations[33].tt_strName = "Rotation Right 7";
	pwo->wo_attTextureTransformations[34].tt_strName = "Rotation Right 8";
	pwo->wo_attTextureTransformations[35].tt_strName = "Rotation Right 9";
	pwo->wo_attTextureTransformations[36].tt_strName = "Rotation Right 10";

	pwo->wo_attTextureTransformations[37].tt_strName = "D Extremly Slow";
	pwo->wo_attTextureTransformations[38].tt_strName = "D Very Slow";
	pwo->wo_attTextureTransformations[39].tt_strName = "D Slow";
	pwo->wo_attTextureTransformations[40].tt_strName = "D Medium";
	pwo->wo_attTextureTransformations[41].tt_strName = "D Fast";
	pwo->wo_attTextureTransformations[42].tt_strName = "D Very Fast";
	pwo->wo_attTextureTransformations[43].tt_strName = "D Extremly Fast";
	pwo->wo_attTextureTransformations[44].tt_strName = "D Super Fast";
	pwo->wo_attTextureTransformations[45].tt_strName = "D Abnormaly Fast";

// static
	pwo->wo_atbTextureBlendings[0].tb_strName         = "Opaque";
	pwo->wo_atbTextureBlendings[0].tb_ubBlendingType  = STXF_BLEND_OPAQUE;

	pwo->wo_atbTextureBlendings[1].tb_strName         = "Shade";
	pwo->wo_atbTextureBlendings[1].tb_ubBlendingType  = STXF_BLEND_SHADE;

	pwo->wo_atbTextureBlendings[2].tb_strName         = "Blend";
	pwo->wo_atbTextureBlendings[2].tb_ubBlendingType  = STXF_BLEND_ALPHA;

	pwo->wo_atbTextureBlendings[3].tb_strName         = "Add";
	pwo->wo_atbTextureBlendings[3].tb_ubBlendingType  = STXF_BLEND_ADD;
// pulsating
	pwo->wo_atbTextureBlendings[4].tb_strName         = "Shade pulsating";
	pwo->wo_atbTextureBlendings[4].tb_ubBlendingType  = STXF_BLEND_SHADE;
	pwo->wo_atbTextureBlendings[4].tb_colMultiply     = 0x808080FF;

	pwo->wo_atbTextureBlendings[5].tb_strName         = "Blend pulsating full";
	pwo->wo_atbTextureBlendings[5].tb_ubBlendingType  = STXF_BLEND_ALPHA;
	pwo->wo_atbTextureBlendings[5].tb_colMultiply     = C_WHITE|0x80;

	pwo->wo_atbTextureBlendings[6].tb_strName         = "Add pulsating";
	pwo->wo_atbTextureBlendings[6].tb_ubBlendingType  = STXF_BLEND_ADD;
	pwo->wo_atbTextureBlendings[6].tb_colMultiply     = 0x808080FF;

	pwo->wo_atbTextureBlendings[7].tb_strName         = "Blend pulsating half";
	pwo->wo_atbTextureBlendings[7].tb_ubBlendingType  = STXF_BLEND_ALPHA;
	pwo->wo_atbTextureBlendings[7].tb_colMultiply     = C_WHITE|0xC0;

	pwo->wo_atbTextureBlendings[8].tb_strName         = "Wsc blend";
	pwo->wo_atbTextureBlendings[8].tb_ubBlendingType  = STXF_BLEND_ALPHA;
	pwo->wo_atbTextureBlendings[8].tb_colMultiply     = C_WHITE|0x00;

	pwo->wo_atbTextureBlendings[9].tb_strName         = "Wsc shade";
	pwo->wo_atbTextureBlendings[9].tb_ubBlendingType  = STXF_BLEND_SHADE;
	pwo->wo_atbTextureBlendings[9].tb_colMultiply     = C_WHITE|0xFF;

	pwo->wo_atbTextureBlendings[10].tb_strName         = "Pyramid plate appearing";
	pwo->wo_atbTextureBlendings[10].tb_ubBlendingType  = STXF_BLEND_ALPHA;
	pwo->wo_atbTextureBlendings[10].tb_colMultiply     = C_WHITE|0x00;

	pwo->wo_atbTextureBlendings[11].tb_strName         = "Activated plate 1";
	pwo->wo_atbTextureBlendings[11].tb_ubBlendingType  = STXF_BLEND_ADD;
	pwo->wo_atbTextureBlendings[11].tb_colMultiply     = C_BLACK|CT_OPAQUE;

	pwo->wo_atbTextureBlendings[12].tb_strName         = "Activated plate 2";
	pwo->wo_atbTextureBlendings[12].tb_ubBlendingType  = STXF_BLEND_ADD;
	pwo->wo_atbTextureBlendings[12].tb_colMultiply     = C_BLACK|CT_OPAQUE;

	pwo->wo_atbTextureBlendings[13].tb_strName         = "Activated plate 3";
	pwo->wo_atbTextureBlendings[13].tb_ubBlendingType  = STXF_BLEND_ADD;
	pwo->wo_atbTextureBlendings[13].tb_colMultiply     = C_BLACK|CT_OPAQUE;

	pwo->wo_atbTextureBlendings[14].tb_strName         = "Activated plate 4";
	pwo->wo_atbTextureBlendings[14].tb_ubBlendingType  = STXF_BLEND_ADD;
	pwo->wo_atbTextureBlendings[14].tb_colMultiply     = C_BLACK|CT_OPAQUE;

	pwo->wo_atbTextureBlendings[15].tb_strName         = "Activate pyramid morph room";
	pwo->wo_atbTextureBlendings[15].tb_ubBlendingType  = STXF_BLEND_ALPHA;
	pwo->wo_atbTextureBlendings[15].tb_colMultiply     = C_WHITE|0x00;
	
//안태훈 수정 시작	//(Modify Worldbase Overbright to NonOver)(0.1)
	pwo->wo_atbTextureBlendings[16].tb_strName         = "Cloud Shade";
	pwo->wo_atbTextureBlendings[16].tb_ubBlendingType  = STXF_BLEND_MODIFIED_SHADE;
	pwo->wo_atbTextureBlendings[16].tb_colMultiply     = g_colNewGameShadeColor;
//안태훈 수정 끝	//(Modify Worldbase Overbright to NonOver)(0.1)

	pwo->wo_aitIlluminationTypes[0].it_strName = "None";
	pwo->wo_aitIlluminationTypes[1].it_strName = "Vitraj 1";
	pwo->wo_aitIlluminationTypes[2].it_strName = "Vitraj 2";
	pwo->wo_aitIlluminationTypes[3].it_strName = "Vitraj 3";
	pwo->wo_aitIlluminationTypes[4].it_strName = "Lava 1";
	pwo->wo_aitIlluminationTypes[5].it_strName = "Lava 2";
	pwo->wo_aitIlluminationTypes[6].it_strName = "Lava 3";
	pwo->wo_aitIlluminationTypes[7].it_strName = "Misc 1";
	pwo->wo_aitIlluminationTypes[8].it_strName = "Misc 2";
	pwo->wo_aitIlluminationTypes[9].it_strName = "Misc 3";

	// surfaces
	pwo->wo_astSurfaceTypes[0].st_strName = "Marble(indoor)";
	pwo->wo_astSurfaceTypes[0].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[0].st_fStairsHeight = 0.6f;
	pwo->wo_astSurfaceTypes[0].st_fJumpSlopeCos = Cos(45.0f);//0331 원래 45도
	pwo->wo_astSurfaceTypes[0].st_fClimbSlopeCos = Cos(45.0f);//45.0f

	pwo->wo_astSurfaceTypes[1].st_strName = "Block(outdoor)";
	pwo->wo_astSurfaceTypes[1].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[1].st_fStairsHeight = 0.6f;
	pwo->wo_astSurfaceTypes[1].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[1].st_fClimbSlopeCos = Cos(45.0f);

	pwo->wo_astSurfaceTypes[2].st_strName = "Wood(outdoor)";
	pwo->wo_astSurfaceTypes[2].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[2].st_fStairsHeight = 0.6f;
	pwo->wo_astSurfaceTypes[2].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[2].st_fClimbSlopeCos = Cos(45.0f);

	pwo->wo_astSurfaceTypes[3].st_strName = "Sand(indoor)";
	pwo->wo_astSurfaceTypes[3].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[3].st_fStairsHeight = 0.6f;
	pwo->wo_astSurfaceTypes[3].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[3].st_fClimbSlopeCos = Cos(45.0f);

	pwo->wo_astSurfaceTypes[4].st_strName = "Water_shallow(indoor)";
	pwo->wo_astSurfaceTypes[4].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[4].st_fStairsHeight = 0.6f;
	pwo->wo_astSurfaceTypes[4].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[4].st_fClimbSlopeCos = Cos(45.0f);

// 강동민 수정 시작		// 싱글 던젼 용
	pwo->wo_astSurfaceTypes[5].st_strName = "Personal Dungeon(indoor)";
	pwo->wo_astSurfaceTypes[5].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[5].st_fStairsHeight = 0.6f;
	pwo->wo_astSurfaceTypes[5].st_fJumpSlopeCos = Cos(90.0f);
	pwo->wo_astSurfaceTypes[5].st_fClimbSlopeCos = Cos(90.0f);
// 강동민 수정 끝		// 싱글 던젼 용

	/*
	pwo->wo_astSurfaceTypes[0].st_strName = "Standard";
	pwo->wo_astSurfaceTypes[0].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[0].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[0].st_fJumpSlopeCos = Cos(70.0f);//0331 원래 45도
	pwo->wo_astSurfaceTypes[0].st_fClimbSlopeCos = Cos(70.0f);//45.0f

	pwo->wo_astSurfaceTypes[1].st_strName = "Ice";
	pwo->wo_astSurfaceTypes[1].st_fFriction = 0.045f;
	pwo->wo_astSurfaceTypes[1].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[1].st_fJumpSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[1].st_fClimbSlopeCos = Cos(5.0f);

	pwo->wo_astSurfaceTypes[2].st_strName = "Standard - no step";
	pwo->wo_astSurfaceTypes[2].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[2].st_fStairsHeight = -0.2f;
	pwo->wo_astSurfaceTypes[2].st_fJumpSlopeCos = Cos(10.0f);
	pwo->wo_astSurfaceTypes[2].st_fClimbSlopeCos = Cos(10.0f);

	pwo->wo_astSurfaceTypes[3].st_strName = "Standard - high stairs";
	pwo->wo_astSurfaceTypes[3].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[3].st_fStairsHeight = 2.0f;
	pwo->wo_astSurfaceTypes[3].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[3].st_fClimbSlopeCos = Cos(45.0f);

	pwo->wo_astSurfaceTypes[4].st_strName = "Ice climbable slope";
	pwo->wo_astSurfaceTypes[4].st_fFriction = 0.05f;
	pwo->wo_astSurfaceTypes[4].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[4].st_fJumpSlopeCos = Cos(15.0f);
	pwo->wo_astSurfaceTypes[4].st_fClimbSlopeCos = Cos(15.0f);

	pwo->wo_astSurfaceTypes[5].st_strName = "Ice sliding slope";
	pwo->wo_astSurfaceTypes[5].st_fFriction = 0.001f;
	pwo->wo_astSurfaceTypes[5].st_fStairsHeight = 0.0f;
	pwo->wo_astSurfaceTypes[5].st_fJumpSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[5].st_fClimbSlopeCos = Cos(5.0f);

	pwo->wo_astSurfaceTypes[6].st_strName = "Ice less sliding";
	pwo->wo_astSurfaceTypes[6].st_fFriction = 0.06f;
	pwo->wo_astSurfaceTypes[6].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[6].st_fJumpSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[6].st_fClimbSlopeCos = Cos(5.0f);

	pwo->wo_astSurfaceTypes[7].st_strName = "Roller coaster";
	pwo->wo_astSurfaceTypes[7].st_fFriction = 0.1f;
	pwo->wo_astSurfaceTypes[7].st_fStairsHeight = 0.0f;
	pwo->wo_astSurfaceTypes[7].st_fJumpSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[7].st_fClimbSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[7].st_ulFlags = STF_SLIDEDOWNSLOPE;

	pwo->wo_astSurfaceTypes[8].st_strName = "Lava";
	pwo->wo_astSurfaceTypes[8].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[8].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[8].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[8].st_fClimbSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[8].st_iWalkDamageType = DMT_BURNING;
	pwo->wo_astSurfaceTypes[8].st_fWalkDamageAmount = 2.0f;
	pwo->wo_astSurfaceTypes[8].st_tmWalkDamageFrequency = 0.5f;
	
	ASSERT(9==SURFACE_SAND);
	pwo->wo_astSurfaceTypes[9].st_strName = "Sand";
	pwo->wo_astSurfaceTypes[9].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[9].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[9].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[9].st_fClimbSlopeCos = Cos(45.0f);

	pwo->wo_astSurfaceTypes[10].st_strName = "Clibamble Slope";
	pwo->wo_astSurfaceTypes[10].st_fFriction = 2.0f;
	pwo->wo_astSurfaceTypes[10].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[10].st_fJumpSlopeCos = Cos(60.0f);
	pwo->wo_astSurfaceTypes[10].st_fClimbSlopeCos = Cos(60.0f);

	pwo->wo_astSurfaceTypes[11].st_strName = "Standard - no impact";
	pwo->wo_astSurfaceTypes[11].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[11].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[11].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[11].st_fClimbSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[11].st_ulFlags = STF_NOIMPACT;

	ASSERT(12==SURFACE_WATER);
	pwo->wo_astSurfaceTypes[12].st_strName = "Water";
	pwo->wo_astSurfaceTypes[12].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[12].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[12].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[12].st_fClimbSlopeCos = Cos(45.0f);

	ASSERT(13==SURFACE_RED_SAND);
	pwo->wo_astSurfaceTypes[13].st_strName = "Red sand";
	pwo->wo_astSurfaceTypes[13].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[13].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[13].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[13].st_fClimbSlopeCos = Cos(45.0f);

	pwo->wo_astSurfaceTypes[14].st_strName = "Ice sliding slope no impact";
	pwo->wo_astSurfaceTypes[14].st_fFriction = 0.001f;
	pwo->wo_astSurfaceTypes[14].st_fStairsHeight = 0.0f;
	pwo->wo_astSurfaceTypes[14].st_fJumpSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[14].st_fClimbSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[14].st_ulFlags = STF_NOIMPACT;

	pwo->wo_astSurfaceTypes[15].st_strName = "Roller coaster no impact";
	pwo->wo_astSurfaceTypes[15].st_fFriction = 0.1f;
	pwo->wo_astSurfaceTypes[15].st_fStairsHeight = 0.0f;
	pwo->wo_astSurfaceTypes[15].st_fJumpSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[15].st_fClimbSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[15].st_ulFlags = STF_SLIDEDOWNSLOPE | STF_NOIMPACT;

	pwo->wo_astSurfaceTypes[16].st_strName = "Standard - high stairs no impact";
	pwo->wo_astSurfaceTypes[16].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[16].st_fStairsHeight = 2.0f;
	pwo->wo_astSurfaceTypes[16].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[16].st_fClimbSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[16].st_ulFlags = STF_NOIMPACT;

	ASSERT(17==SURFACE_GRASS);
	pwo->wo_astSurfaceTypes[17].st_strName = "Grass";
	pwo->wo_astSurfaceTypes[17].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[17].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[17].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[17].st_fClimbSlopeCos = Cos(45.0f);

	ASSERT(18==SURFACE_WOOD);
	pwo->wo_astSurfaceTypes[18].st_strName = "Wood";
	pwo->wo_astSurfaceTypes[18].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[18].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[18].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[18].st_fClimbSlopeCos = Cos(45.0f);

	ASSERT(19==SURFACE_GRASS_SLIDING);
	pwo->wo_astSurfaceTypes[19].st_strName = "Grass sliding";
	pwo->wo_astSurfaceTypes[19].st_fFriction = 0.1f;
	pwo->wo_astSurfaceTypes[19].st_fStairsHeight = 0.0f;
	pwo->wo_astSurfaceTypes[19].st_fJumpSlopeCos = Cos(5.0f);
	pwo->wo_astSurfaceTypes[19].st_fClimbSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[19].st_ulFlags = STF_SLIDEDOWNSLOPE;

 
	ASSERT(20==SURFACE_GRASS_NOIMPACT);
	pwo->wo_astSurfaceTypes[20].st_strName = "Grass no impact";
	pwo->wo_astSurfaceTypes[20].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[20].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[20].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[20].st_fClimbSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[20].st_ulFlags = STF_NOIMPACT;

	ASSERT(21==SURFACE_SNOW);
	pwo->wo_astSurfaceTypes[21].st_strName = "Snow";
	pwo->wo_astSurfaceTypes[21].st_fFriction = 1.0f;
	pwo->wo_astSurfaceTypes[21].st_fStairsHeight = 1.0f;
	pwo->wo_astSurfaceTypes[21].st_fJumpSlopeCos = Cos(45.0f);
	pwo->wo_astSurfaceTypes[21].st_fClimbSlopeCos = Cos(45.0f);
	*/
	
	// contents
	pwo->wo_actContentTypes[0].ct_strName = "Air";
	pwo->wo_actContentTypes[0].ct_fDensity = 0.0f;
	pwo->wo_actContentTypes[0].ct_fFluidFriction     = 0.0f;
	pwo->wo_actContentTypes[0].ct_fControlMultiplier = 1.0f;
	pwo->wo_actContentTypes[0].ct_fSpeedMultiplier = 1.0f;
	pwo->wo_actContentTypes[0].ct_fDrowningDamageAmount = 10.0f;
	pwo->wo_actContentTypes[0].ct_tmDrowningDamageDelay = 1.0f;
	pwo->wo_actContentTypes[0].ct_ulFlags = CTF_FLYABLE|CTF_BREATHABLE_LUNGS;

	pwo->wo_actContentTypes[1].ct_strName = "Water";
	pwo->wo_actContentTypes[1].ct_fDensity = 1000.0f;
	pwo->wo_actContentTypes[1].ct_fFluidFriction     = 0.0f;
	pwo->wo_actContentTypes[1].ct_fControlMultiplier = 2.0f;
	pwo->wo_actContentTypes[1].ct_fSpeedMultiplier = 0.75f;
	pwo->wo_actContentTypes[1].ct_fDrowningDamageAmount = 10.0f;
	pwo->wo_actContentTypes[1].ct_tmDrowningDamageDelay = 1.0f;
	pwo->wo_actContentTypes[1].ct_ulFlags = CTF_BREATHABLE_GILLS|CTF_SWIMABLE|CTF_FADESPINNING;

	pwo->wo_actContentTypes[2].ct_strName = "Lava";
	pwo->wo_actContentTypes[2].ct_fDensity = 800.0f;
	pwo->wo_actContentTypes[2].ct_fFluidFriction     = 1.0f;
	pwo->wo_actContentTypes[2].ct_fControlMultiplier = 2.0f;
	pwo->wo_actContentTypes[2].ct_fSpeedMultiplier = 0.5f;
	pwo->wo_actContentTypes[2].ct_fDrowningDamageAmount = 0.0f;
	pwo->wo_actContentTypes[2].ct_tmDrowningDamageDelay = 1.0f;
	pwo->wo_actContentTypes[2].ct_iSwimDamageType = DMT_BURNING;
	pwo->wo_actContentTypes[2].ct_fSwimDamageAmount = 50.0f;
	pwo->wo_actContentTypes[2].ct_tmSwimDamageFrequency = 0.25f;
	pwo->wo_actContentTypes[2].ct_ulFlags = CTF_FADESPINNING;

	pwo->wo_actContentTypes[3].ct_strName = "Cold Water";
	pwo->wo_actContentTypes[3].ct_fDensity = 1000.0f;
	pwo->wo_actContentTypes[3].ct_fFluidFriction     = 0.0f;
	pwo->wo_actContentTypes[3].ct_fControlMultiplier = 2.0f;
	pwo->wo_actContentTypes[3].ct_fSpeedMultiplier = 0.75f;
	pwo->wo_actContentTypes[3].ct_fDrowningDamageAmount = 10.0f;
	pwo->wo_actContentTypes[3].ct_tmDrowningDamageDelay = 1.0f;
	pwo->wo_actContentTypes[3].ct_iSwimDamageType = DMT_FREEZING;
	pwo->wo_actContentTypes[3].ct_fSwimDamageAmount = 1.0f;
	pwo->wo_actContentTypes[3].ct_tmSwimDamageDelay = 5.0f;
	pwo->wo_actContentTypes[3].ct_tmSwimDamageFrequency = 1.0f;
	pwo->wo_actContentTypes[3].ct_ulFlags = CTF_BREATHABLE_GILLS|CTF_SWIMABLE|CTF_FADESPINNING;

	pwo->wo_actContentTypes[4].ct_strName = "Spikes";
	pwo->wo_actContentTypes[4].ct_fDensity = 500.0f;
	pwo->wo_actContentTypes[4].ct_fFluidFriction     = 0.5f;
	pwo->wo_actContentTypes[4].ct_fControlMultiplier = 1.0f;
	pwo->wo_actContentTypes[4].ct_fSpeedMultiplier = 0.75f;
	pwo->wo_actContentTypes[4].ct_iKillDamageType = DMT_SPIKESTAB;
	pwo->wo_actContentTypes[4].ct_fKillImmersion = 0.5f;
	pwo->wo_actContentTypes[4].ct_ulFlags = CTF_BREATHABLE_LUNGS|CTF_FADESPINNING;

	pwo->wo_actContentTypes[5].ct_strName = "Desert heat";
	pwo->wo_actContentTypes[5].ct_fDensity = 0.0f;
	pwo->wo_actContentTypes[5].ct_fFluidFriction     = 0.0f;
	pwo->wo_actContentTypes[5].ct_fControlMultiplier = 1.0f;
	pwo->wo_actContentTypes[5].ct_fSpeedMultiplier = 1.0f;
	pwo->wo_actContentTypes[5].ct_iSwimDamageType = DMT_HEAT;
	pwo->wo_actContentTypes[5].ct_fSwimDamageAmount = 10.0f;
	pwo->wo_actContentTypes[5].ct_tmSwimDamageDelay = 10.0f;
	pwo->wo_actContentTypes[5].ct_tmSwimDamageFrequency = 2.0f;
	pwo->wo_actContentTypes[5].ct_ulFlags = CTF_FLYABLE|CTF_BREATHABLE_LUNGS;

	pwo->wo_actContentTypes[6].ct_strName = "Lava (-10HP/SEC)";
	pwo->wo_actContentTypes[6].ct_fDensity = 1000.0f;
	pwo->wo_actContentTypes[6].ct_fFluidFriction     = 0.0f;
	pwo->wo_actContentTypes[6].ct_fControlMultiplier = 2.0f;
	pwo->wo_actContentTypes[6].ct_fSpeedMultiplier = 0.75f;
	pwo->wo_actContentTypes[6].ct_fDrowningDamageAmount = 0.0f;
	pwo->wo_actContentTypes[6].ct_tmDrowningDamageDelay = 1.0f;
	pwo->wo_actContentTypes[6].ct_iSwimDamageType = DMT_BURNING;
	pwo->wo_actContentTypes[6].ct_fSwimDamageAmount = 5.0f;
	pwo->wo_actContentTypes[6].ct_tmSwimDamageFrequency = 0.5f;
	pwo->wo_actContentTypes[6].ct_ulFlags = CTF_SWIMABLE|CTF_FADESPINNING;

	// sound environments FX
	pwo->wo_aetEnvironmentTypes[ 0].et_strName = "Normal";
	pwo->wo_aetEnvironmentTypes[ 0].et_iType = SEFX_NORMAL;

	pwo->wo_aetEnvironmentTypes[ 1].et_strName = "Generic";
	pwo->wo_aetEnvironmentTypes[ 1].et_iType = SEFX_GENERIC;

	pwo->wo_aetEnvironmentTypes[ 2].et_strName = "Small room";
	pwo->wo_aetEnvironmentTypes[ 2].et_iType = SEFX_LIVINGROOM;

	pwo->wo_aetEnvironmentTypes[ 3].et_strName = "Medium room";
	pwo->wo_aetEnvironmentTypes[ 3].et_iType = SEFX_STONEROOM;

	pwo->wo_aetEnvironmentTypes[ 4].et_strName = "Big room";
	pwo->wo_aetEnvironmentTypes[ 4].et_iType = SEFX_AUDITORIUM;

	pwo->wo_aetEnvironmentTypes[ 5].et_strName = "Corridor";
	pwo->wo_aetEnvironmentTypes[ 5].et_iType = SEFX_HALLWAY;

	pwo->wo_aetEnvironmentTypes[ 6].et_strName = "Arena";
	pwo->wo_aetEnvironmentTypes[ 6].et_iType = SEFX_ARENA;

	pwo->wo_aetEnvironmentTypes[ 7].et_strName = "Long corridor";
	pwo->wo_aetEnvironmentTypes[ 7].et_iType = SEFX_STONEHALL;

	pwo->wo_aetEnvironmentTypes[ 8].et_strName = "Small canyon";
	pwo->wo_aetEnvironmentTypes[ 8].et_iType = SEFX_QUARRY;

	pwo->wo_aetEnvironmentTypes[ 9].et_strName = "Big canyon";
	pwo->wo_aetEnvironmentTypes[ 9].et_iType = SEFX_MOUNTAINS;

	pwo->wo_aetEnvironmentTypes[10].et_strName = "Open space";
	pwo->wo_aetEnvironmentTypes[10].et_iType = SEFX_PLAIN;
																
	pwo->wo_aetEnvironmentTypes[11].et_strName = "Cave";
	pwo->wo_aetEnvironmentTypes[11].et_iType = SEFX_CAVE;
																
	pwo->wo_aetEnvironmentTypes[12].et_strName = "Sewers";
	pwo->wo_aetEnvironmentTypes[12].et_iType = SEFX_SEWERPIPE;

	pwo->wo_aetEnvironmentTypes[13].et_strName = "Hangar";
	pwo->wo_aetEnvironmentTypes[13].et_iType = SEFX_HANGAR;

	pwo->wo_aetEnvironmentTypes[14].et_strName = "Forest";
	pwo->wo_aetEnvironmentTypes[14].et_iType = SEFX_FOREST;

	pwo->wo_aetEnvironmentTypes[15].et_strName = "Concert Hall";
	pwo->wo_aetEnvironmentTypes[15].et_iType = SEFX_CONCERTHALL;

	pwo->wo_aetEnvironmentTypes[16].et_strName = "Underwater";
	pwo->wo_aetEnvironmentTypes[16].et_iType = SEFX_UNDERWATER;

	// declare console variables
	_pShell->DeclareSymbol("user void MakeWorldStatistics(void);",  &MakeWorldStatistics);
	_pShell->DeclareSymbol("user void ReoptimizeAllBrushes(void);", &ReoptimizeAllBrushes);
	_pShell->DeclareSymbol("user void DoLevelSafetyChecks(void);", &DoLevelSafetyChecks);
	_pShell->DeclareSymbol("user void ConvertSingleMH2ToMH3(CTString);", &ConvertSingleMH2ToMH3);  
	_pShell->DeclareSymbol("user void ConvertAllMH2ToMH3(void);", &ConvertAllMH2ToMH3);    
	_pShell->DeclareSymbol("user void ConversionCheckForMH2(CTString, INDEX);", &ConversionCheckForMH2);  

}

void CWorldBase_OnWorldRender(CWorld *pwo)
{
	// get current tick
	TIME tmNow = _pTimer->GetLerpedCurrentTick();
	// wrap time to prevent texture coordinates to get unprecise
	tmNow = fmod(tmNow, 600.0); // (wrap every 10 minutes)

// transformations
//안태훈 수정 시작	//(Add & Modify SSSE Effect)(0.1)
	// right
	pwo->wo_attTextureTransformations[1].tt_mdTransformation.md_fUOffset= 128/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[2].tt_mdTransformation.md_fUOffset= 256/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[3].tt_mdTransformation.md_fUOffset= 512/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[4].tt_mdTransformation.md_fUOffset=1024/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[5].tt_mdTransformation.md_fUOffset=2048/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[6].tt_mdTransformation.md_fUOffset=4096/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[7].tt_mdTransformation.md_fUOffset=8192/1024.0f*tmNow * 0.010f;
	
	// down
	pwo->wo_attTextureTransformations[37].tt_mdTransformation.md_fVOffset= 128/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[38].tt_mdTransformation.md_fVOffset= 256/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[39].tt_mdTransformation.md_fVOffset= 512/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[40].tt_mdTransformation.md_fVOffset=1024/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[41].tt_mdTransformation.md_fVOffset=2048/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[42].tt_mdTransformation.md_fVOffset=4096/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[43].tt_mdTransformation.md_fVOffset=8192/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[44].tt_mdTransformation.md_fVOffset=8192*2/1024.0f*tmNow * 0.010f;
	pwo->wo_attTextureTransformations[45].tt_mdTransformation.md_fVOffset=8192*4/1024.0f*tmNow * 0.010f;
//안태훈 수정 끝	//(Add & Modify SSSE Effect)(0.1)

//안태훈 수정 시작	//(Modify Worldbase Overbright to NonOver)(0.1)
	pwo->wo_atbTextureBlendings[16].tb_colMultiply     = g_colNewGameShadeColor;
//안태훈 수정 끝	//(Modify Worldbase Overbright to NonOver)(0.1)

	CMappingDefinitionUI mdui;
	mdui.mdui_fUStretch = 1.0f;
	mdui.mdui_fVStretch = 1.0f;
	mdui.mdui_fUOffset = 0.0f;
	mdui.mdui_fVOffset = 0.0f;
	// rotations left
	mdui.mdui_aURotation = 8192*1/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*1/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[17].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*2/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*2/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[18].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*4/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*4/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[19].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*8/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*8/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[20].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*16/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*16/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[21].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*32/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*32/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[22].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*64/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*64/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[23].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*128/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*128/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[24].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = 8192*256/1024.0f*tmNow;
	mdui.mdui_aVRotation = 8192*256/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[25].tt_mdTransformation.FromUI(mdui);
	// rotations right
	mdui.mdui_aURotation = -8192*1/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*1/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[27].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*2/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*2/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[28].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*4/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*4/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[29].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*8/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*8/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[30].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*16/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*16/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[31].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*32/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*32/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[32].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*64/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*64/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[33].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*128/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*128/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[34].tt_mdTransformation.FromUI(mdui);
	mdui.mdui_aURotation = -8192*256/1024.0f*tmNow;
	mdui.mdui_aVRotation = -8192*256/1024.0f*tmNow;
	pwo->wo_attTextureTransformations[35].tt_mdTransformation.FromUI(mdui);
// blendings
	FLOAT f = Abs(Sin(tmNow*AngleDeg(180.0f)));
	pwo->wo_atbTextureBlendings[4].tb_colMultiply = RGBAToColor(f*255, f*255, f*255, 255);
	pwo->wo_atbTextureBlendings[5].tb_colMultiply = C_WHITE|UBYTE(255*f);
	pwo->wo_atbTextureBlendings[6].tb_colMultiply = RGBAToColor(f*255, f*255, f*255, 255);
	pwo->wo_atbTextureBlendings[7].tb_colMultiply = C_WHITE|UBYTE(255*Lerp(0.5f, 1.0f, f));

	pwo->wo_attTextureTransformations[11].tt_mdTransformation.md_fUOffset=Sin( tmNow*22)/30;
	pwo->wo_attTextureTransformations[11].tt_mdTransformation.md_fVOffset=Cos( tmNow*26)/35;

	pwo->wo_attTextureTransformations[12].tt_mdTransformation.md_fUOffset=Sin( tmNow*32)/10;
	pwo->wo_attTextureTransformations[12].tt_mdTransformation.md_fVOffset=Cos( tmNow*22)/15;

	pwo->wo_attTextureTransformations[13].tt_mdTransformation.md_fUOffset=Sin( tmNow*15)/7;
	pwo->wo_attTextureTransformations[13].tt_mdTransformation.md_fVOffset=Cos( tmNow*25)/8;

	pwo->wo_attTextureTransformations[14].tt_mdTransformation.md_fUOffset=Sin( tmNow*32)/3;
	pwo->wo_attTextureTransformations[14].tt_mdTransformation.md_fVOffset=Cos( tmNow*22)/3;

	pwo->wo_attTextureTransformations[15].tt_mdTransformation.md_fUOffset=Sin( tmNow*15);
	pwo->wo_attTextureTransformations[15].tt_mdTransformation.md_fVOffset=Cos( tmNow*25);

	// ----------- Obtain world settings controller
	CWorldSettingsController *pwsc = NULL;
	// obtain bcg viewer
	CBackgroundViewer *penBcgViewer = (CBackgroundViewer *) pwo->GetBackgroundViewer();
	if( penBcgViewer != NULL)
	{
		// obtain world settings controller 
		pwsc = (CWorldSettingsController *) &*penBcgViewer->m_penWorldSettingsController;
	}
	
	// ***** Storm effects
	// if world settings controller is valid
	if( pwsc != NULL)
	{
		FLOAT fStormFactor = pwsc->GetStormFactor();
		COLOR colBlend = LerpColor( pwsc->m_colBlendStart, pwsc->m_colBlendStop, fStormFactor);
		pwo->wo_atbTextureBlendings[8].tb_colMultiply = colBlend;

		// set world polygon shading multiplier
		COLOR colShade = LerpColor( pwsc->m_colShadeStart, pwsc->m_colShadeStop, fStormFactor);

		// apply lightning FX
		if( pwsc->m_tmLightningStart != -1)
		{
			FLOAT tmLightningLife = tmNow-pwsc->m_tmLightningStart;
			_aoLightningColor.ao_tmAnimStart = pwsc->m_tmLightningStart;
			COLOR colLightning = _aoLightningColor.GetFrame();
			// calculate lightning power factor
			UBYTE ub = UBYTE( pwsc->m_fLightningPower*255);
			COLOR colFactor = RGBToColor( ub, ub, ub) | CT_OPAQUE;
			colLightning = MulColors( colLightning, colFactor);
			colShade = AddColors( colShade, colLightning);
		}
		pwo->wo_atbTextureBlendings[9].tb_colMultiply = colShade;
	}

	// ***** Pyramid blending effects
	// if world settings controller is valid
	if( pwsc != NULL)
	{
		// set alpha values for switch-controlled pyramid plate activating
		SetPyramidPlateActivateAlpha(pwo, 10, pwsc->m_tmPyramidPlatesStart, 1e6, FALSE);
		SetPyramidPlateActivateAlpha(pwo, 11, pwsc->m_tmActivatedPlate1, pwsc->m_tmDeactivatedPlate1, TRUE);
		SetPyramidPlateActivateAlpha(pwo, 12, pwsc->m_tmActivatedPlate2, pwsc->m_tmDeactivatedPlate2, TRUE);
		SetPyramidPlateActivateAlpha(pwo, 13, pwsc->m_tmActivatedPlate3, pwsc->m_tmDeactivatedPlate3, TRUE);
		SetPyramidPlateActivateAlpha(pwo, 14, pwsc->m_tmActivatedPlate4, pwsc->m_tmDeactivatedPlate4, TRUE);
		// pyramid morph room
		SetPyramidMorphRoomAlpha(pwo, 15, pwsc->m_tmPyramidMorphRoomActivated);
	}
};

void CWorldBase_OnInitClass(void)
{
	// init particle effects
	InitParticles();
	try
	{
		// setup simple model shadow texture
		_toSimpleModelShadow.SetData_t( CTFILENAME("Data\\Textures\\Effects\\Shadow\\SimpleModelShadow.tex"));
		_aoLightningColor.SetData_t( CTFILENAME("Data\\etc\\Lightning.ani"));
		// we will use first animation in .ani file for lightning
		_aoLightningColor.PlayAnim(0, AOF_NORESTART);
	}
	catch(char *strError)
	{
		FatalError(TRANS("Cannot load shadow texture: \n%s"), strError);
	}
}

void CWorldBase_OnEndClass(void)
{
	_aoLightningColor.SetData(NULL);
	_toSimpleModelShadow.SetData_t(CTFileName(""));
	// close particle effects
	CloseParticles();
}

class CFixedForce {
public:
	CTString ff_strName;
	class CForceStrength ff_fsGravity;
	class CForceStrength ff_fsField;
	
	inline CFixedForce(CTString strName,
		FLOAT3D vDirection,
		FLOAT fAcceleration,
		FLOAT fVelocity)
	{
		ff_strName = strName;
		ff_fsGravity.fs_vDirection     =vDirection;
		ff_fsGravity.fs_fAcceleration  =fAcceleration;
		ff_fsGravity.fs_fVelocity      =fVelocity;
	}

};

static CFixedForce affFixedForces[] = 
{
	CFixedForce ("Normal D", FLOAT3D( 0,-1, 0), 30, 70),
	CFixedForce ("Normal U", FLOAT3D( 0,+1, 0), 30, 70),
	CFixedForce ("Normal N", FLOAT3D( 0, 0,-1), 30, 70),
	CFixedForce ("Normal S", FLOAT3D( 0, 0,+1), 30, 70),
	CFixedForce ("Normal E", FLOAT3D(-1, 0, 0), 30, 70),
	CFixedForce ("Normal W", FLOAT3D(+1, 0, 0), 30, 70),
	CFixedForce ("ZeroG",    FLOAT3D(+1, 0, 0), 0, 0),
	CFixedForce ("Unused",   FLOAT3D(+1, 0, 0), 0, 0),
	CFixedForce ("Unused",   FLOAT3D(+1, 0, 0), 0, 0),
	CFixedForce ("Unused",   FLOAT3D(+1, 0, 0), 0, 0),
};
static INDEX ctFixedForces = ARRAYCOUNT(affFixedForces);
extern void GetDefaultForce(INDEX iForce, const FLOAT3D &vPoint, 
		CForceStrength &fsGravity, CForceStrength &fsField)
{
	if (iForce<ctFixedForces) {
		fsGravity = affFixedForces[iForce].ff_fsGravity;
	}
}

void CWorldBase::SetDefaultProperties(void) {
  m_strName = "World Base";
  m_strDescription = "";
  m_bZoning = FALSE ;
  m_bBackground = FALSE ;
  m_bAnchored = FALSE ;
  m_bCollision = TRUE ;
  m_penGravity0 = NULL;
  m_penGravity1 = NULL;
  m_penGravity2 = NULL;
  m_penGravity3 = NULL;
  m_penGravity4 = NULL;
  m_penGravity5 = NULL;
  m_penGravity6 = NULL;
  m_penGravity7 = NULL;
  m_penGravity8 = NULL;
  m_penGravity9 = NULL;
  m_penFog0 = NULL;
  m_penFog1 = NULL;
  m_penFog2 = NULL;
  m_penFog3 = NULL;
  m_penFog4 = NULL;
  m_penFog5 = NULL;
  m_penFog6 = NULL;
  m_penFog7 = NULL;
  m_penFog8 = NULL;
  m_penFog9 = NULL;
  m_penHaze0 = NULL;
  m_penHaze1 = NULL;
  m_penHaze2 = NULL;
  m_penHaze3 = NULL;
  m_penHaze4 = NULL;
  m_penMirror0 = NULL;
  m_penMirror1 = NULL;
  m_penMirror2 = NULL;
  m_penMirror3 = NULL;
  m_penMirror4 = NULL;
  m_penGradient0 = NULL;
  m_penGradient1 = NULL;
  m_penGradient2 = NULL;
  m_penGradient3 = NULL;
  m_penGradient4 = NULL;
  m_penGradient5 = NULL;
  m_penGradient6 = NULL;
  m_penGradient7 = NULL;
  m_penGradient8 = NULL;
  m_penGradient9 = NULL;
  m_penGradient10 = NULL;
  m_penGradient11 = NULL;
  m_penGradient12 = NULL;
  m_penGradient13 = NULL;
  m_penGradient14 = NULL;
  m_penGradient15 = NULL;
  m_penGradient16 = NULL;
  m_penGradient17 = NULL;
  m_penGradient18 = NULL;
  m_penGradient19 = NULL;
  m_cbClassificationBits = 0;
  m_vbVisibilityBits = 0;
  m_fOpacity = 1.0f;
  m_bRenderReflection = FALSE ;
  CEntity::SetDefaultProperties();
}
  
#line 1440 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ULONG CWorldBase::GetVisTweaks(void) 
#line 1441 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1442 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return m_cbClassificationBits  | m_vbVisibilityBits ;
#line 1443 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1446 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
BOOL CWorldBase::IsTargetValid(SLONG slPropertyOffset,CEntity * penTarget) 
#line 1447 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1448 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(penTarget  == NULL )
#line 1449 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1450 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return FALSE ;
#line 1451 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1453 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ULONG  ulFirst  , ulLast ;
#line 1456 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulFirst  = offsetof  (CWorldBase  , m_penGradient0 );
#line 1457 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulLast  = offsetof  (CWorldBase  , m_penGradient19 );
#line 1458 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(slPropertyOffset  >= ulFirst  && slPropertyOffset  <= ulLast ){
#line 1459 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return IsDerivedFromClass  (penTarget  , & CGradientMarker_DLLClass );
#line 1460 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1463 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulFirst  = offsetof  (CWorldBase  , m_penGravity0 );
#line 1464 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulLast  = offsetof  (CWorldBase  , m_penGravity9 );
#line 1465 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(slPropertyOffset  >= ulFirst  && slPropertyOffset  <= ulLast ){
#line 1466 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return IsDerivedFromClass  (penTarget  , & CGravityMarker_DLLClass ) 
#line 1467 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
|| IsDerivedFromClass  (penTarget  , & CGravityRouter_DLLClass );
#line 1468 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1471 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulFirst  = offsetof  (CWorldBase  , m_penMirror0 );
#line 1472 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulLast  = offsetof  (CWorldBase  , m_penMirror4 );
#line 1473 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(slPropertyOffset  >= ulFirst  && slPropertyOffset  <= ulLast ){
#line 1474 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return IsDerivedFromClass  (penTarget  , & CMirrorMarker_DLLClass );
#line 1475 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1478 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulFirst  = offsetof  (CWorldBase  , m_penFog0 );
#line 1479 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulLast  = offsetof  (CWorldBase  , m_penFog9 );
#line 1480 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(slPropertyOffset  >= ulFirst  && slPropertyOffset  <= ulLast ){
#line 1481 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return IsDerivedFromClass  (penTarget  , & CFogMarker_DLLClass );
#line 1482 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1485 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulFirst  = offsetof  (CWorldBase  , m_penHaze0 );
#line 1486 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
ulLast  = offsetof  (CWorldBase  , m_penHaze4 );
#line 1487 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(slPropertyOffset  >= ulFirst  && slPropertyOffset  <= ulLast ){
#line 1488 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return IsDerivedFromClass  (penTarget  , & CHazeMarker_DLLClass );
#line 1489 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1491 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return CEntity  :: IsTargetValid  (slPropertyOffset  , penTarget );
#line 1492 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1495 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
const CTString & CWorldBase::GetForceName(INDEX iForce) 
#line 1496 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1497 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strDummyName  ("");
#line 1498 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strMarkerUnused  ("Marker not set");
#line 1499 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctGravityMarkers  = & m_penGravity9  - & m_penGravity0  + 1;
#line 1501 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iForce  < ctFixedForces ){
#line 1502 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return affFixedForces  [ iForce  ] . ff_strName ;
#line 1503 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1504 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iForce  - ctFixedForces  <= ctGravityMarkers ){
#line 1505 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CEntity  * pen  = & * (& m_penGravity0 ) [ iForce  - ctFixedForces  ];
#line 1506 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pen  != NULL ){
#line 1507 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return pen  -> GetForceName  (0);
#line 1508 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1509 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strMarkerUnused ;
#line 1510 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1512 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1513 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strDummyName ;
#line 1514 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1515 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1517 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
void CWorldBase::GetForce(INDEX iForce,const FLOAT3D & vPoint,
#line 1518 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CForceStrength & fsGravity,CForceStrength & fsField) 
#line 1519 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1520 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctGravityMarkers  = & m_penGravity9  - & m_penGravity0  + 1;
#line 1521 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iForce  < ctFixedForces ){
#line 1522 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
fsGravity  = affFixedForces  [ iForce  ] . ff_fsGravity ;
#line 1523 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1524 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iForce  - ctFixedForces  < ctGravityMarkers ){
#line 1525 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CEntity  * pen  = & * (& m_penGravity0 ) [ iForce  - ctFixedForces  ];
#line 1526 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pen  != NULL ){
#line 1527 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
pen  -> GetForce  (0 , vPoint  , fsGravity  , fsField );
#line 1528 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return ;
#line 1529 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1530 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1531 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
fsGravity  . fs_fAcceleration  = 30;
#line 1532 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
fsGravity  . fs_fVelocity  = 70;
#line 1533 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
fsGravity  . fs_vDirection  = FLOAT3D (1 , 0 , 0);
#line 1534 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1535 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
fsField  . fs_fAcceleration  = 0;
#line 1536 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
fsField  . fs_fVelocity  = 0;
#line 1537 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1540 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CEntity * CWorldBase::GetForceController(INDEX iForce) 
#line 1541 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1542 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctGravityMarkers  = & m_penGravity9  - & m_penGravity0  + 1;
#line 1543 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iForce  < ctFixedForces ){
#line 1544 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return NULL ;
#line 1545 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1546 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iForce  - ctFixedForces  < ctGravityMarkers ){
#line 1547 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CEntity  * pen  = & * (& m_penGravity0 ) [ iForce  - ctFixedForces  ];
#line 1548 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pen  != NULL ){
#line 1549 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return pen  -> GetForceController  (0);
#line 1550 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1551 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1552 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1553 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return NULL ;
#line 1554 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1556 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
const CTString & CWorldBase::GetFogName(INDEX iFog) 
#line 1557 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1558 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctFogMarkers  = & m_penFog9  - & m_penFog0  + 1;
#line 1559 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strDummyName  ("");
#line 1560 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strMarkerUnused  ("Marker not set");
#line 1561 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iFog  < ctFogMarkers ){
#line 1562 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CFogMarker  * pfm  = (CFogMarker  *) & * (& m_penFog0 ) [ iFog  ];
#line 1563 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pfm  != NULL ){
#line 1564 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return pfm  -> GetFogName  ();
#line 1565 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1566 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strMarkerUnused ;
#line 1567 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1568 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1569 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strDummyName ;
#line 1570 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1572 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
BOOL CWorldBase::GetFog(INDEX iFog,class CFogParameters & fpFog) 
#line 1573 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1574 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctFogMarkers  = & m_penFog8  - & m_penFog0  + 1;
#line 1575 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iFog  < ctFogMarkers ){
#line 1576 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CFogMarker  * pfm  = (CFogMarker  *) & * (& m_penFog0 ) [ iFog  ];
#line 1577 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pfm  != NULL ){
#line 1578 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
pfm  -> GetFog  (fpFog );
#line 1579 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return TRUE ;
#line 1580 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1581 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1582 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return FALSE ;
#line 1583 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1586 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
const CTString & CWorldBase::GetHazeName(INDEX iHaze) 
#line 1587 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1588 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctHazeMarkers  = & m_penHaze4  - & m_penHaze0  + 1;
#line 1589 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strDummyName  ("");
#line 1590 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strMarkerUnused  ("Marker not set");
#line 1591 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iHaze  < ctHazeMarkers ){
#line 1592 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CHazeMarker  * pfm  = (CHazeMarker  *) & * (& m_penHaze0 ) [ iHaze  ];
#line 1593 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pfm  != NULL ){
#line 1594 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return pfm  -> GetHazeName  ();
#line 1595 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1596 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strMarkerUnused ;
#line 1597 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1598 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1599 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strDummyName ;
#line 1600 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1603 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
BOOL CWorldBase::GetHaze(INDEX iHaze,class CHazeParameters & hpHaze,FLOAT3D & vViewDir) 
#line 1604 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1605 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctHazeMarkers  = & m_penHaze4  - & m_penHaze0  + 1;
#line 1606 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iHaze  < ctHazeMarkers ){
#line 1607 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CHazeMarker  * phm  = (CHazeMarker  *) & * (& m_penHaze0 ) [ iHaze  ];
#line 1608 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(phm  != NULL ){
#line 1609 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
phm  -> GetHaze  (hpHaze  , vViewDir );
#line 1610 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return TRUE ;
#line 1611 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1612 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1613 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return FALSE ;
#line 1614 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1617 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
const CTString & CWorldBase::GetMirrorName(INDEX iMirror) 
#line 1618 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1619 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strDummyName  ("");
#line 1620 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strMarkerUnused  ("Marker not set");
#line 1621 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iMirror  == 0){
#line 1622 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strDummyName ;
#line 1623 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1625 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
switch(iMirror ){
#line 1626 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 1: {static const CTString str  ("std mirror 1");return str ;};break ;
#line 1627 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 2: {static const CTString str  ("std mirror 2");return str ;};break ;
#line 1628 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 3: {static const CTString str  ("std mirror 3");return str ;};break ;
#line 1629 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 4: {static const CTString str  ("std mirror 4");return str ;};break ;
#line 1630 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 5: {static const CTString str  ("std mirror 5");return str ;};break ;
#line 1631 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 6: {static const CTString str  ("std mirror 6");return str ;};break ;
#line 1632 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 7: {static const CTString str  ("std mirror 7");return str ;};break ;
#line 1633 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
case 8: {static const CTString str  ("std mirror 8");return str ;};break ;
#line 1634 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
default  :{
#line 1635 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
iMirror  -= 9;
#line 1636 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctMirrorMarkers  = & m_penMirror4  - & m_penMirror0  + 1;
#line 1637 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iMirror  < ctMirrorMarkers ){
#line 1638 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CMirrorMarker  * pfm  = (CMirrorMarker  *) & * (& m_penMirror0 ) [ iMirror  ];
#line 1639 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pfm  != NULL ){
#line 1640 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return pfm  -> GetMirrorName  ();
#line 1641 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1642 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strMarkerUnused ;
#line 1643 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1644 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1645 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1646 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1647 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strDummyName ;
#line 1648 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1651 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
BOOL CWorldBase::GetMirror(INDEX iMirror,class CMirrorParameters & mpMirror) 
#line 1652 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1653 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iMirror  == 0){
#line 1654 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return FALSE ;
#line 1655 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1656 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iMirror  >= 1 && iMirror  <= 8){
#line 1657 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
mpMirror  . mp_ulFlags  = 0;
#line 1658 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return TRUE ;
#line 1659 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1660 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
iMirror  -= 9;
#line 1661 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctMirrorMarkers  = & m_penMirror4  - & m_penMirror0  + 1;
#line 1662 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iMirror  < ctMirrorMarkers ){
#line 1663 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CMirrorMarker  * pmm  = (CMirrorMarker  *) & * (& m_penMirror0 ) [ iMirror  ];
#line 1664 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pmm  != NULL ){
#line 1665 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
pmm  -> GetMirror  (mpMirror );
#line 1666 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return TRUE ;
#line 1667 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1668 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1669 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return FALSE ;
#line 1670 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1673 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
const CTString & CWorldBase::GetGradientName(INDEX iGradient) 
#line 1674 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1675 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctGradientMarkers  = & m_penGradient19  - & m_penGradient0  + 1;
#line 1676 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strDummyName  ("");
#line 1677 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
static const CTString strMarkerUnused  ("Marker not set");
#line 1678 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(iGradient  < ctGradientMarkers ){
#line 1679 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CGradientMarker  * pgm  = (CGradientMarker  *) & * (& m_penGradient0 ) [ iGradient  ];
#line 1680 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pgm  != NULL ){
#line 1681 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return pgm  -> GetGradientName  ();
#line 1682 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1683 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strMarkerUnused ;
#line 1684 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1685 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1686 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return strDummyName ;
#line 1687 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1689 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
void CWorldBase::UncacheShadowsForGradient(class CGradientMarker * penDiscard) 
#line 1690 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1691 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctGradientMarkers  = & m_penGradient19  - & m_penGradient0  + 1;
#line 1692 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
for(INDEX iGradient  = 0;iGradient  < ctGradientMarkers ;iGradient  ++)
#line 1693 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1694 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CGradientMarker  * pgm  = (CGradientMarker  *) & * (& m_penGradient0 ) [ iGradient  ];
#line 1695 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pgm  == penDiscard )
#line 1696 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1697 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CEntity  :: UncacheShadowsForGradient  (iGradient  + 1);
#line 1698 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1699 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1700 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1703 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
BOOL CWorldBase::GetGradient(INDEX iGradient,class CGradientParameters & fpGradient) 
#line 1704 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1705 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
INDEX ctGradientMarkers  = & m_penGradient19  - & m_penGradient0  + 1;
#line 1706 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if((iGradient  < ctGradientMarkers ) && (iGradient  > 0)){
#line 1707 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
CGradientMarker  * pgm  = (CGradientMarker  *) & * (& m_penGradient0 ) [ iGradient  - 1 ];
#line 1708 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(pgm  != NULL ){
#line 1709 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return pgm  -> GetGradient  (0 , fpGradient );
#line 1710 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1711 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1712 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return FALSE ;
#line 1713 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1716 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
BOOL CWorldBase::HandleEvent(const CEntityEvent & ee) 
#line 1717 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1719 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(ee  . ee_slEvent  == EVENTCODE_EFirstWorldBase ){
#line 1720 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () | ENF_ZONING );
#line 1721 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
m_bZoning  = TRUE ;
#line 1722 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () | ENF_ANCHORED );
#line 1723 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
m_bAnchored  = TRUE ;
#line 1724 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return TRUE ;
#line 1725 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1726 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return FALSE ;
#line 1727 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1731 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SLONG CWorldBase::GetUsedMemory(void) 
#line 1732 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1734 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SLONG  slUsedMemory  = sizeof  (CWorldBase ) - sizeof  (CEntity ) + CEntity  :: GetUsedMemory  ();
#line 1736 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
slUsedMemory  += m_strName  . Length  ();
#line 1737 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
slUsedMemory  += m_strDescription  . Length  ();
#line 1738 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return slUsedMemory ;
#line 1739 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
  
#line 1743 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
FLOAT CWorldBase::GetOpacity(void) 
#line 1744 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1745 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return m_fOpacity ;
#line 1746 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
BOOL CWorldBase::
#line 1753 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
Main(const CEntityEvent &__eeInput) {
#undef STATE_CURRENT
#define STATE_CURRENT STATE_CWorldBase_Main
  ASSERTMSG(__eeInput.ee_slEvent==EVENTCODE_EVoid, "CWorldBase::Main expects 'EVoid' as input!");  const EVoid &evoid = (const EVoid &)__eeInput;
#line 1755 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlagOn  (ENF_MARKDESTROY );
#line 1756 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlagOn  (ENF_NONETCONNECT );
#line 1757 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlagOff  (ENF_PROPSCHANGED );
#line 1759 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlagOff  (ENF_RENDERREFLECTION );
#line 1763 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
InitAsBrush  ();
#line 1766 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(m_bRenderReflection )
#line 1767 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1768 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlagOn  (ENF_RENDERREFLECTION );
#line 1769 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1771 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetPhysicsFlags  (EPF_BRUSH_FIXED );
#line 1773 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(m_bCollision )
#line 1774 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1775 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetCollisionFlags  (ECF_BRUSH );
#line 1776 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1777 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
else 
#line 1778 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
{
#line 1779 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetCollisionFlags  (ECF_MODEL_NO_COLLISION );
#line 1780 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1784 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(m_bZoning ){
#line 1785 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
m_strDescription  = "zoning";
#line 1786 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () | ENF_ZONING );
#line 1787 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1788 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
m_strDescription  = "non zoning";
#line 1789 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () & ~ ENF_ZONING );
#line 1790 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1793 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(m_bBackground ){
#line 1794 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
m_strDescription  += " background";
#line 1795 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () | ENF_BACKGROUND );
#line 1796 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1797 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () & ~ ENF_BACKGROUND );
#line 1798 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1801 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
if(m_bAnchored ){
#line 1802 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
m_strDescription  += " anchored";
#line 1803 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () | ENF_ANCHORED );
#line 1804 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}else {
#line 1805 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
SetFlags  (GetFlags  () & ~ ENF_ANCHORED );
#line 1806 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
}
#line 1808 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
Return(STATE_CURRENT,EVoid());
#line 1808 "E:/질산/Korea/Client_USA/EntitiesMP/WorldBase.es"
return TRUE; ASSERT(FALSE); return TRUE;};